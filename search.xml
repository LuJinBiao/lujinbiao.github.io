<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo个性化设置（持续更新）]]></title>
    <url>%2F2018%2F10%2F24%2FHexo%2FHexo%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[把文章置顶并添加置顶标志首先更换依赖：12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的 Front-matter 中加上 top: true 即可。比如下面这篇文章：12345title: 常见的内部排序算法date: 2018/10/18 20:46:03categories: 算法tags: top: true 最后添加置顶标志，打开：/blog/themes/next/layout/_macro 目录下的post.swig 文件，定位到 &lt;div class=&quot;post-meta&quot;&gt; 标签下，插入如下代码：12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 把 sideBar 设置在左边调整首页文章间距打开 \themes\next\source\css\_schemes\Mist\_posts-expanded.styl ，在最后一行添加1234.posts-expand .post &#123; margin-top: 50px; //调整到自己合适的数值 margin-bottom: 00px; //调整到自己合适的数值&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ASCII、Unicode 和 UTF-8 的关系]]></title>
    <url>%2F2018%2F10%2F20%2FJava%2FASCII%E5%92%8CUnicode-%E4%BB%A5%E5%8F%8AUTF-8%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[偶然在其他地方看到以下这篇关于 ASCII、Unicode 和 UTF-8 之间关系的起源说明，看完之后豁然开朗，必须留下来做个记录。 ASCII我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有 0 和 1 两种状态，因此八个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从 00000000 到 11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了 128 个字符的编码，比如空格 SPACE 是 32（二进制00100000），大写的字母 A 是 65（二进制 01000001）。这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为 0。 非 ASCII 编码英语用 128 个符号编码就够了，但是用来表示其他语言，128 个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为 130（二进制 10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多 256 个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用 256 个符号的编码方式，代表的字母却不一样。比如，130 在法语编码中代表了 é，在希伯来语编码中却代表了字母 Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127 表示的符号是一样的，不一样的只是 128–255 的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示 256 种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号 中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是 GB 类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 Unicode正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639 表示阿拉伯字母 Ain，U+0041 表示英语的大写字母 A，U+4E25 表示汉字 ‘严’。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 Unicode 的问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字 ‘严’ 的 Unicode 是十六进制数 4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。 UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有两条： 对于单字节的符号，字节的第一位设为 0，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于 n 字节的符号（n &gt; 1），第一个字节的前 n 位都设为 1，第 n + 1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用于编码的位。 跟据上表，解读 UTF-8 编码非常简单。对于一个二进制的 UTF-8 编码，如果一个字节的第一位是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。 下面，还是以汉字 ‘严’ 为例，演示如何实现 UTF-8 编码。 严的 Unicode 是 4E25（100111000100101），根据上表，可以发现 4E25 处在第三行的范围内（0000 0800 - 0000 FFFF），因此 ‘严’ 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx。然后，从 ‘严’ 的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补 0。这样就得到了，严的 UTF-8 编码是 11100100 10111000 10100101，转换成十六进制就是 E4B8A5。 Unicode 和 UTF-8 之间的转换通过上一节的例子，可以看到严的 Unicode码 是4E25，UTF-8 编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。 Windows平台，有一个最简单的转化方法，就是使用内置的记事本小程序notepad.exe。打开文件后，点击文件菜单中的另存为命令，会跳出一个对话框，在最底部有一个编码的下拉条。 里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。 ANSI 是默认的编码方式。对于英文文件是 ASCII 编码，对于简体中文文件是 GB2312 编码（只针对 Windows 简体中文版，如果是繁体中文版会采用 Big5 码）。 Unicode 编码这里指的是 notepad.exe 使用的 UCS-2 编码方式，即直接用两个字节存入字符的 Unicode 码，这个选项用的 little endian 格式。 Unicode big endian 编码与上一个选项相对应。我在下一节会解释 little endian 和 big endian 的涵义。 UTF-8编码，也就是上一节谈到的编码方法。 选择完 “编码方式” 后，点击 “保存” 按钮，文件的编码方式就立刻转换好了。 Little endian 和 Big endian上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字 ‘严’ 为例，Unicode 码是4E25，需要用两个字节存储，一个字节是 4E，另一个字节是 25。存储的时候，4E 在前，25 在后，这就是 Big endian 方式；25 在前，4E 在后，这是 Little endian 方式。 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 第一个字节在前，就是 “大头方式”（Big endian），第二个字节在前就是 “小头方式”（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做 “零宽度非换行空格”（zero width no-break space），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大 1。 如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大头方式；如果头两个字节是 FF FE，就表示该文件采用小头方式。 实例下面，举一个实例。 打开”记事本”程序 notepad.exe，新建一个文本文件，内容就是一个严字，依次采用 ANSI，Unicode，Unicode big endian 和 UTF-8 编码方式保存。 然后，用文本编辑软件 UltraEdit 中的”十六进制功能”，观察该文件的内部编码方式。 ANSI：文件的编码就是两个字节 D1 CF，这正是严的 GB2312 编码，这也暗示 GB2312 是采用大头方式存储的。 Unicode：编码是四个字节 FF FE 25 4E，其中 FF FE 表明是小头方式存储，真正的编码是 4E25。 Unicode big endian：编码是四个字节 FE FF 4E 25，其中 FE FF 表明是大头方式存储。 UTF-8：编码是六个字节 EF BB BF E4 B8 A5，前三个字节 EF BB BF 表示这是 UTF-8 编码，后三个 E4B8A5 就是严的具体编码，它的存储顺序与编码顺序是一致的。 补充现在，捋一捋 ASCII 编码和 Unicode 编码的区别：ASCII 编码是 1 个字节，而 Unicode 编码通常是2个字节。 字母 A 用 ASCII 编码是十进制的 65，二进制的 01000001； 字符 0 用 ASCII 编码是十进制的 48，二进制的 00110000，注意字符 &#39;0&#39; 和整数 0 是不同的； 汉字 中 已经超出了 ASCII 编码的范围，用 Unicode 编码是十进制的 20013，二进制的 01001110 00101101。 你可以猜测，如果把ASCII编码的 A 用Unicode编码，只需要在前面补 0 就可以，因此，A 的Unicode编码是 00000000 01000001。 新的问题又出现了：如果统一成 Unicode 编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把 Unicode 编码转化为 “可变长编码” 的 UTF-8 编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果你要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间： 字符 ASCII Unicode UTF-8 A 0100 0001 0000 0000 0100 0001 0100 0001 中 x 0100 1110 0010 1101 1110 0100 1011 1000 1010 1101 从上面的表格还可以发现，UTF-8 编码有一个额外的好处，就是 ASCII 编码实际上可以被看成是 UTF-8 编码的一部分，所以，大量只支持 ASCII 编码的历史遗留软件可以在 UTF-8 编码下继续工作。 搞清楚了 ASCII、Unicode 和 UTF-8 的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式： 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件： 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器： 所以你看到很多网页的源码上会有类似 &lt;meta charset=&quot;UTF-8&quot; /&gt; 的信息，表示该网页正是用的 UTF-8 编码。 参考资料 谈谈Unicode编码 How to determine string is ASCII or Unicode?]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的内部排序算法]]></title>
    <url>%2F2018%2F10%2F18%2F%E7%AE%97%E6%B3%95%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常见的内部排序方法可以分为6大类，具体有10种： 选择排序（直接选择排序、堆排序） 交换排序（冒泡排序、快速排序） 插入排序（直接插入排序、折半插入排序、Shell排序） 归并排序 桶式排序 基数排序 选择排序常用的选择排序有：直接选择排序 和 堆排序。直接选择排序简单但是性能差，堆排序较为高效但是实现起来复杂。 直接选择排序直接选择排序的思路很简单，第 1 趟比较，把记录定位到第 1 个数据上，拿第 1 个数据依次和它后面每个数据进行比较，如果第 1 个数据大于后面某个数据，变换它们。第 1 趟结束后最小的数据被排在第1 位。同理可得，经过 n-1 趟比较后，完成排序。 123456789101112131415public static void selectSort(int[] data)&#123; for (int i = 0; i &lt; data.length-1; i++) &#123; for (int j = i+1; j &lt; data.length; j++) &#123; if (data[i]&gt;data[j]) &#123; int temp=data[i]; data[i]=data[j]; data[j]=temp; &#125; &#125; &#125;&#125; 堆积排序堆积是一种特殊的二叉树，可分为最大堆积树和最小堆积树。 最大堆积树满足3个条件：它是一个完全二叉树；所有节点的值都大于或等于它左右子节点的值；树根是堆积树中最大的。 最小堆积树满足3个条件：它是一个完全二叉树；所有节点的值都小于或等于它左右子节点的值；树根是堆积树中最小的。 堆积排序首先要对原始数据进行建立堆积树。通过不断重复如下步骤(以建最大堆积树为例)： 从最后一个非叶子节点开始，比较该节点和它两个子节点的值，如果某个子节点的值大于父节点的值，把父节点和较大的子节点交换。向前逐步调整直到根节点，即保证每个父节点的值都大于或等于其左右子节点的值，建堆完成。 有数据序列：34、19、40、14、57、17、4、43，以二叉树表示： 交换排序交换排序的主体操作是对数据组中的数据不断进行交换操作，主要有冒泡排序和快速排序。 冒泡排序原理：气泡在水底时，水压最大，气泡最小；但慢慢浮上水面时，气泡由小逐渐变大。当有 n 个元素时算法执行 n-1 次扫描，第 i 次扫描执行 n-i 次比较。 123456789101112131415161718192021public static void bubbleSort(int[] origin) &#123; for (int i = 1; i &lt; origin.length; i++) &#123; int flag = 0;//flag标记用来记录是否有执行过交换动作，并记录次数 for (int j = 0; j &lt; origin.length - i; j++) &#123; if (origin[j] &gt; origin[j + 1]) &#123; int temp = origin[j]; origin[j] = origin[j + 1]; origin[j + 1] = temp; flag++; &#125; &#125; if (flag == 0) &#123; break; &#125; &#125; &#125; 快速排序快速排序法又称为分割交换排序法，是目前公认最佳的排序法。它的原理和冒泡排序法一样都是用交换的方式，不过它会先在数据中找到一个虚拟的中间值，把小于中间值的数据放到左边，而大于中间值的数据放到右边，再以同样的方式分别处理左右两边的数据，直到完成排序为止。 插入排序直接插入排序直接插入排序是将数组中的元素，逐一与已排序好的数据作比较，再将该元素插入适当的位置。 在步骤二中，以 4 为基准与其他元素比较后，放到适当位置(6的前面)，步骤三则拿 9 与其他两个元素比较，接着 8 在比较完前三个数后插入 9 的前面….直至完成排序。 1234567891011121314151617public static void insertSort(int[] origin) &#123; //扫描次数为 n-1 次 for (int i = 1; i &lt; origin.length; i++) &#123; int temp = origin[i]; if (origin[i] &lt; origin[i - 1]) &#123; int j = i - 1; for (; j &gt;= 0 &amp;&amp; origin[j] &gt; temp; j--) &#123; origin[j + 1] = origin[j]; &#125; origin[j + 1] = temp; &#125; &#125; &#125; 折半插入排序Shell排序希尔排序法类似于直接插入排序法，但它可以减少数据搬移的次数。排序的原则是将数据区划分成特定间隔的几个小区块，以插入排序法排序完区块内的数据后再渐渐减少间隔的距离。 归并排序桶式排序基数排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 下的包管理工具]]></title>
    <url>%2F2018%2F09%2F07%2FLinux%2Fyum%E5%92%8Capt%2F</url>
    <content type="text"><![CDATA[Linux 的软件安装目录是也是有讲究的，理解这一点，在对系统管理是有益的 /usr：系统级的目录，可以理解为 C:/Windows/，/usr/lib 理解为 C:/Windows/System32。/usr/local：用户级的程序目录，可以理解为 C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。/opt：用户级的程序目录，可以理解为 D:/Software，opt 有可选的意思，这里可以用于放置第三方大型软件(或游戏)，当你不需要时，直接 rm -rf 掉即可。在硬盘容量不够时，也可将 /opt 单独挂载到其他磁盘上使用。 源码放哪里？/usr/src：系统级的源码目录。/usr/local/src：用户级的源码目录。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-多表连接查询]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[SQL99 的连接查询SQL99 连接查询的可读性比 SQL92 连接查询更强，查询用的多个数据表显式使用 xxx join 连接，而不是直接依次排列在 from 之后，from 后只需要放一个数据表；连接条件不再放在 where 之后，而是提供了专门的连接条件子句。 SQL99 支持如下几种多表连接查询： 交叉连接。 自然连接。 使用 using 子句的连接。 使用 on 子句的连接。 全外连接或者 左、右外连接。 内连接(inner join)内连接使用比较运算符进行表与表之间某些列数据的比较操作，并列出这些表中与连接条件相匹配的数据行，组合成新记录。只有满足条件的记录才能出现在结果关系中。123select suppliers.*,fruits.*from fruits inner join supplierson fruits.s_id=suppliers.s_id; 交叉连接(cross join)交叉连接效果就是 SQL92 中的广义笛卡尔积，所以交叉条件无须任何连接条件：123select s.*,teacher_namefrom student_table scross join teacher_table t; 自然连接(natural join)自然连接表面上看起来也无须指定连接条件，但自然连接的确是具有连接条件的，自然连接会以两个表中的同名列作为连接条件；如果两个表中没有同名列，则自然连接与交叉连接效果完全一样：123select s.*,teacher_namefrom student_table snatural join teacher_table t; using 子句连接using 子句可以指定一列或多列，用于显式指定两个表中的同名列作为连接条件。假设两个表中有超过一列的同名列，如果使用 natural join，则会把所有的同名列当成连接条件；使用 using 子句，就可显式指定使用哪些同名列作为连接条件：1234select s.*,teacher_namefrom student_table sjoin teacher_table tusing(teacher_id); 要注意，如果使用 using 子句来指定连接条件，则两个表中必须有同名列，否则就会报错。 on 子句连接SQL99 语法的连接条件放在 on 子句中指定，而且每个 on 子句只指定一个连接条件，意味着如果需要进行 N 表连接，就需要有 N-1 个 join…on 对：1234select s.*,teacher_namefrom student_table sjoin teacher_table ton s.java_teacher=t.teacher_id; 左、右 外连接这三种外连接分别使用 left [outer] join、right [outer] join、full [outer] join，这三种外连接的连接条件一样通过 on 子句来指定，既可以是等值连接条件，又可以是非等值连接条件。 左连接的结果包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果行中，右表的所有选择列表列均为空值。 以下是 左外连接、右外连接的示例，仔细区分二者之间的区别，尤其是如何区分 左表 和 右表： MySQL 不支持全外连接。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原码-反码-补码]]></title>
    <url>%2F2018%2F06%2F04%2FJava%2F%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81%2F</url>
    <content type="text"><![CDATA[提前基础–机器数和真值 机器数一个数在计算机的二进制表示形式，称作这个数的机器数。机器数带符号，在最高位存放符号，正数为 0，负数为 1。 真值因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如符号数 10000011，其最高位 1 代表负数，其真正数值是 -3，而不是 131(10000011转换成十进制等于131)。所以，为了区别，将带有符号位的机器数对应的真正数值称为机器数的真值。 原码,反码,补码的基本概念和计算方法原码原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。例如一字节的8位二进制：[+1]=0000 0001，[-1]=1000 0001。因为第一位是符号位，所以 8 位二进制的取值范围是 [1111 1111，0111 1111]，即 [-127，127]。 补码补码的表示方法是：正数的补码是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后加 1(即在反码的基础上加1)。[+1]=[0000 0001]原=[0000 0001]反=[0000 0001]补[-1]=[1000 0001]原=[1111 1110]反=[1111 1111]补 反码反码的表示方法是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。[+1]=[0000 0001]原=[0000 0001]反[-1]=[1000 0001]原=[1111 1110]反 为何要使用原码，反码和补码(待补充)对于正数因为三种编码方式的结果都相同，所以不再讨论，而对于负数：[-1]=[1000 0001]原=[1111 1110]反=[1111 1111]补]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Maven-聚合与继承]]></title>
    <url>%2F2018%2F05%2F26%2FMaven%2FMaven-%E8%81%9A%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[对于一个较为复杂的软件，往往采用各种方式对软件进行划分模块，以得到更清晰的设计以及更到的重用性。当把 Maven 应用到实际项目中的时候，也需要将项目分成不同的模块。 对于一个账户注册服务，可以把它划分为 account-email、account-persist、account-service 等5个模块。 现在通过创建一个额外的名为 account-aggregator 的模块，然后通过该模块构建整个项目的所有模块。 作为一个聚合项目，account-aggregator 的 POM 文件需要特殊处理：123456789&lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt;&lt;artifactId&gt;account-aggregator&lt;/artifactId&gt;&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;name&gt;Account Aggregator&lt;/name&gt;&lt;modules&gt;&lt;module&gt;account-email&lt;/module&gt;&lt;module&gt;account-persist&lt;/module&gt;&lt;/modules&gt; 上面 POM 的元素 modules 是实现聚合的最核心配置。用户可以通过在一个打包方式为 pom 的 Maven 项目中声明任意数量的 module 元素来实现模块的聚合。 这里的每一个 module 的值都是一个当前 POM 的相对目录。为了方便构建项目，通常将聚合模块放在项目目录的最顶层，其他模块作为聚合模块的子目录存在。 从聚合模块运行 mvn clean install 命令。 继承可以创建 POM 的父子结构，然后在父 POM 中声明一些配置供子 POM 继承，以实现一处声明，多处使用的目的。 在 account-aggregator 下创建一个名为 account-parent 的子目录，然后在该子目录下建立一个所有除 account-aggregator 之外模块的父模块。为此，在该子目录创建一个 pom.xml 文件：12345&lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt;&lt;artifactId&gt;account-parent&lt;/artifactId&gt;&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;name&gt;Account Parent&lt;/name&gt; 该父 POM 使用了与其他模块一致的 groupId 和 version。 有了父模块，就可以让其他模块来继承它。首先将 account-email 的 POM 修改如下：123456789&lt;parent&gt;&lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt;&lt;artifactid&gt;account-parent&lt;/artifactid&gt;&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;relativePath&gt;../account-parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;&lt;artifactId&gt;account-email&lt;/artifactId&gt;&lt;name&gt;Account Email&lt;/name&gt; 使用 parent 元素来声明父模块。该子模块隐式从父模块继承了 groupId 和 version，如果需要修改，可以显式声明，对于 artifactId，必须显式声明。 最后，还需要把 account-parent 模块加入到聚合模块 account-aggregator 中。 可继承的 POM 元素以下是一个完整的列表，表示哪些元素可以被继承：12345678910111213141516171819- groupId：项目组 ID- version：项目版本- description：项目的描述信息- organization：项目的组织信息- inceptionYear：项目的创始年份- url：项目的 URL 地址- develoers：项目的开发者信息- contributors：项目的贡献者信息- distributionManagement：项目的部署配置- issueManagement：项目的缺陷跟踪系统信息- ciManagement：项目的持续集成系统信息- scm：项目的版本控制系统信息- mailingLists：项目的邮件列表信息- properties：自定义的 Maven 属性- dependencies：项目的依赖配置- dependencyManagement：项目的依赖管理配置- repositories：项目的仓库配置- build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等- reporting：包括项目的报告输出目录配置、报告插件配置等 依赖管理依赖是可以被继承的。但是我们无法确定将来添加的子模块就一定需要父模块的某些依赖。因此，dependencyManagement 元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性。 在 dependencyManagement 元素下的依赖声明不会引入实际的依赖，不过它能够约束 dependencies 下的依赖使用。 在 account-parent 父模块中配置 dependenciesManagement 元素：123456789101112131415161718192021222324252627&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 这里使用 dependenciesManagement 声明的依赖既不会该 account-parent 引入依赖，也不会给它的子模块引入依赖，不过这一段配置是会被继承的。 现在修改 account-email 的 POM：123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在子模块的依赖配置中省略了 version，因为继承了父模块中的 dependenciesManagement 配置，完整的依赖声明已经包含在父 POM 中，子模块只需要配置简单的 groupId 和 artifactId 就能获得对于的依赖信息。 如果子模块不在 &lt;dependencies&gt; 中声明依赖的使用，即使该依赖已经在父 POM 的 dependenciesManagement 中声明了，也不会产生任何实际的效果。 插件管理类似于依赖管理，pluginManagement 元素用来帮助管理插件。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mavan-build]]></title>
    <url>%2F2018%2F05%2F19%2FMaven%2FMavan-build%2F</url>
    <content type="text"><![CDATA[pom.xml 中存在两种 &lt;build&gt;： 一种 &lt;build&gt; 是 &lt;project&gt; 的直接子元素。 另一种 &lt;build&gt; 被称为 Profile Build，即是 &lt;profile&gt; 的直接子元素。 Profile Build 包含了基本的 build 元素，而 Project Build 还包含两个特殊的元素，即各种 &lt;...Directory&gt; 和 &lt;extensions&gt;。 Profile Build 和 Project Build 共用的基本 build 元素：&lt;&gt;12345&lt;build&gt; &lt;defaultGoal&gt;install&lt;/defaultGoal&gt; &lt;directory&gt;$&#123;basedir&#125;/target&lt;/directory&gt; &lt;finalName&gt;$&#123;artifactId&#125;-$&#123;version&#125;&lt;/finalName&gt;&lt;/build&gt; defaultGoal，执行构建时默认的 goal 或 phase，如 jar:jar 或者 package 等。 directory，构建的结果所在的路径，默认为 ${basedir}/target 目录。 finalName，构建的最终结果的名字，该名字可能在其他 plugin 中被改变。 资源往往不是代码，无需编译，而是一些 properties 或 XML 配置文件，构建过程中会往往会将资源文件从源路径复制到指定的目标路径。1234567891011121314151617181920212223&lt;build&gt; ... &lt;filters&gt; &lt;filter&gt;filters/filter1.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;META-INF/plexus&lt;/targetPath&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/plexus&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;configuration.xml&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; ... &lt;/testResources&gt; ... &lt;/build&gt; resources，build过程中涉及的资源文件。 targetPath，资源文件的目标路径。 filtering，构建过程中是否对资源进行过滤，默认false。 directory，资源文件的路径，默认位于 ${basedir}/src/main/resources/ 目录下。 includes，一组文件名的匹配模式，被匹配的资源文件将被构建过程处理。 excludes，一组文件名的匹配模式，被匹配的资源文件将被构建过程忽略。同时被includes和excludes匹配的资源文件，将被忽略。 filters，给出对资源文件进行过滤的属性文件的路径，默认位于${basedir}/src/main/filters/目录下。属性文件中定义若干键值对。在构建过程中，对于资源文件中出现的变量（键），将使用属性文件中该键对应的值替换。 testResources，test过程中涉及的资源文件，默认位于${basedir}/src/test/resources/目录下。这里的资源文件不会被构建到目标构件中。 123456789101112131415161718&lt;build&gt; ... &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;extensions&gt;false&lt;/extensions&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;configuration&gt; &lt;classifier&gt;test&lt;/classifier&gt; &lt;/configuration&gt; &lt;dependencies&gt;...&lt;/dependencies&gt; &lt;executions&gt;...&lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; groupId artifactId version extensions，是否加载该插件的扩展，默认false inherited，该插件的configuration中的配置是否可以被（继承该POM的其他Maven项目）继承，默认true configuration，该插件所需要的特殊配置，在父子项目之间可以覆盖或合并 dependencies，该插件所特有的依赖类库 executions，该插件的某个goal（一个插件中可能包含多个goal）的执行方式。一个execution有如下设置：id，唯一标识goals，要执行的插件的goal（可以有多个），如runphase，插件的goal要嵌入到Maven的phase中执行，如verifyinherited，该execution是否可被子项目继承configuration，该execution的其他配置参数 &lt;pluginManagement&gt;在 &lt;build&gt; 中，&lt;pluginManagement&gt; 与 &lt;plugins&gt; 并列，两者之间的关系类似于 &lt;dependencyManagement&gt; 与 &lt;dependencies&gt; 之间的关系。 &lt;pluginManagement&gt; 中也配置 &lt;plugin&gt;，其配置参数与 &lt;plugins&gt; 中的 &lt;plugin&gt; 完全一致。只是，&lt;pluginManagement&gt; 往往出现在父项目中，其中配置的 &lt;plugin&gt; 往往通用于子项目。子项目中只要在 &lt;plugins&gt; 中以 &lt;plugin&gt; 声明该插件，该插件的具体配置参数则继承自父项目中 &lt;pluginManagement&gt; 对该插件的配置，从而避免在子项目中进行重复配置。 Project Build特有的 &lt;...Directory&gt;往往配置在父项目中，供所有父子项目使用。示例如下：123456789 &lt;build&gt; &lt;sourceDirectory&gt;$&#123;basedir&#125;/src/main/java&lt;/sourceDirectory&gt; &lt;scriptSourceDirectory&gt;$&#123;basedir&#125;/src/main/scripts&lt;/scriptSourceDirectory&gt; &lt;testSourceDirectory&gt;$&#123;basedir&#125;/src/test/java&lt;/testSourceDirectory&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/target/classes&lt;/outputDirectory&gt; &lt;testOutputDirectory&gt;$&#123;basedir&#125;/target/test-classes&lt;/testOutputDirectory&gt; ... &lt;/build&gt; &lt;/project&gt; 目录可以使用绝对路径，如示例所示。如果使用相对路径，则所有的相对路径都是在${basedir}目录下。 Project Build特有的 &lt;extensions&gt;是执行构建过程中可能用到的其他工具，在执行构建的过程中被加入到classpath中。 也可以通过激活构建插件，从而改变构建的过程。 通常，通过给出通用插件的一个具体实现，用于构建过程。1234567891011&lt;build&gt; ... &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;org.apache.maven.wagon&lt;/groupId&gt; &lt;artifactId&gt;wagon-ftp&lt;/artifactId&gt; &lt;version&gt;1.0-alpha-3&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; ... &lt;/build&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 通过位运算操作状态]]></title>
    <url>%2F2018%2F05%2F09%2FJava%2FJava%E9%80%9A%E8%BF%87%E4%BD%8D%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[首先通过定义一组静态常量来定义多个状态：1234public static final int OP_READ = 1&lt;&lt;0;public static final int OP_WRITE = 1&lt;&lt;2;public static final int OP_CONNECT = 1&lt;&lt;3;public static final int OP_ACCEPT = 1&lt;&lt;4; 如果把它们转换为二进制：12341&lt;&lt;0: 0000 00011&lt;&lt;2: 0000 01001&lt;&lt;3: 0000 10001&lt;&lt;4: 0001 0000 可以发现，一个数如果是 2 的幂，则它的二进制数都只有一个位为 1，其余位数都是 0. 存储状态下面再来定义一个变量，用来存储状态(默认值是 0)：1private static int STATUS = 0; 当需要保存状态时，直接用按位或运算 | ：12//假如需要保存状态 OP_READSTATUS = STATUS | OP_READ; 保存的运算过程如下：123450000 0000 执行 | 运算0000 0001---------0000 0001 相当于把 1 这个状态值存储到 0 的二进制当中。 可以在 STATUS 中存储多个状态值，STATUS = OP_READ | OP_WRITE | OP_CONNECT 判断状态那么如果要判断变量 STATUS 中是否有某个状态呢？这时候需要使用 &amp; 运算：1( STATUS &amp; OP_READ ) != 0 //true,代表含有 OP_READ 计算过程如下：123450000 0001 执行 &amp; 运算0000 0001---------0000 0001 再来判断一个不存在的状态 STATUS &amp; OP_WRITE：1( STATUS &amp; OP_WRITE ) != 0; //false,代表不含有 OP_WRITE 计算过程如下：123450000 0001 执行 &amp; 运算0000 0010----------0000 0000 = 0 因为 OP_WRITE 这个状态的二进制位，1 的位置处，STATUS 的二进制并没有对应的 1，而又因为其他位都是 0，导致全部归 0，计算出来的结果自然也就是 0 了。 这也就是为什么定义状态的数字中，都是 2 的次幂，因为它们的特点就是二进制只有一个为 1 的位，其他位都是 0，并同其他数位 1 的位不冲突。 移除已存储状态现在知道了如何存储和判断状态，那么如何移除已经存储的状态呢？这时候就要用到非运算 ^ 。假设 STATUS 中已经存储了 OP_CONNECT 这个状态，要把它从 STATUS 中移除，可以写：1STATUS = STATUS ^ OP_CONNECT 计算过程：123450000 1000 执行 ^ 运算0000 1000---------0000 0000 可以见到 STATUS 中已经没有了 OP_CONNECT 的状态值了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS3 选择器]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%89%8D%E7%AB%AF%2FCSS%2F</url>
    <content type="text"><![CDATA[CSS 样式的语法总是遵循如下格式：1234Selector&#123; property1:value; property2:value;&#125; 属性选择器 E{ …} ：指定该 CSS 样式对所有 E 元素起作用（即元素选择器）。 E[attr]{…}：指定该 CSS 样式对具有 attr 属性的 E 元素起作用。 E[attr=value]{…}：指定该 CSS 样式对所有包含 attr 属性，且 attr 属性为 value 的 E 元素起作用。 E[attr~=value]{…}：指定该 CSS 样式对所有包含 attr 属性，且 attr 属性的值为以空格隔开的系列值，其中某个值为 value 的 E 元素起作用。 E[attr|=value]{…}：指定该 CSS 样式对所有包含 attr 属性，且 attr 属性的值为以连字符分隔的系列值，其中第一个值为 value 的 Tag 元素起作用。 E[attr^=”value]{…}：指定该 CSS 样式对所有包含 attr 属性，且 attr 属性的值为以 value 开头的字符串的 E 元素起作用。 E[attr$=”value”]{…}：指定该 CSS 样式对所有包含 attr 属性，且 attr 属性的值为以 value 结尾的字符串的 E 元素起作用。 E[att*=”value”]{…}：指定该 CSS 样式对所有包含 attr 属性，且 attr 属性的值为包含 value 的字符串的 E 元素起作用。 上面这几个选择器匹配规则越严格优先级越高。 ID 选择器ID 选择器指定 CSS 样式将会对具有指定 id 属性值的 HTML 元素起作用：1#idValue&#123;...&#125; 仅对指定元素起作用的 ID 选择器：1E#idValue&#123;...&#125; 类选择器类选择器指定 CSS 样式对具有指定 class 属性的元素起作用：1[E].classValue&#123;...&#125; /*其中 E 是有效的HTML元素*/ 包含选择器包含选择器用于指定目标选择器必须处于某个选择器对应的元素内部：1Selector1 Selector2&#123;...&#125; 如果还希望实现更为精确的选择，例如只对 section 元素下的article 元素下的 h1 元素应用样式：123section article h1&#123; font-size:30px;&#125; 子选择器子选择器用于指定目标选择器必须是某个选择器对应的子元素：1Selector1&gt;Selector2&#123;...&#125; 包含选择器与子选择器十分相似，它们之间存在如下区别：对于包含选择器，只要目标选择器位于外部选择器对应的元素内部，即使是 “孙子元素” 也可以；对于子选择器，要求目标选择器必须作为外部选择器对应的元素的直接子元素才可以。 兄弟选择器兄弟选择器是 CSS 3.0 新增的一个选择器：1Selector1 ~ Selector2&#123;...&#125; 兄弟选择器匹配与 Selector1 对应的元素后面、能匹配 Selector2 的兄弟节点。 示范：12345678910111213&lt;style type=&quot;text/css&quot;&gt; //匹配 id 为 android 的元素后面、class 属性为 long 的兄弟节点 #android ~ .long &#123; background-color: #00FF00;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;long&quot;&gt;&lt;/div&gt;//不被匹配 &lt;div id=&quot;android&quot;&gt;&lt;/div&gt; &lt;div class=&quot;long&quot;&gt;&lt;/div&gt;//被匹配 &lt;p class=&quot;long&quot;&gt;&lt;/p&gt;//被匹配&lt;/body&gt; CSS 中还有多种基于关系的选择器，如 a &gt; b 表示选择任何 a 元素的子元素 b，a + b 表示任何 a 元素的下一个 b 元素，a:first-child 表示任何 a 元素的第一个子元素。 选择器组合如果想让一份 CSS 样式对多个选择器起作用，可以利用选择器组合来实现：1Selector1,Selector2,Selector3,...&#123;...&#125; 对于上面的组合选择器，{…} 中定义的 CSS 样式将会对前面列出的所有选择器匹配出的元素起作用。 伪元素选择器伪元素并不是针对真正的元素使用的选择器，而是对元素中的特定内容进行操作。设计伪元素的目的就是去选取诸如元素内容第一个字(母)、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。 CSS 提供的伪元素有如下几个： :first-letter：对指定对象内的第一个字符起作用。注意 :first-letter 选择器仅对块元素起作用 :first-line：对指定对象内的第一行内容起作用。仅对块元素起作用 :before：在指定对象内部的前端插入内容。 :after：在指定对象内部的尾端插入内容。 12345678&lt;style type="text/css"&gt;span&#123; display:block;&#125;span:first-letter&#123; color:red; font-size:20pt;&#125; 内容相关的属性这里的内容相关的属性，与 CSS 属性中 color、font-size 等属性本质是相同的。这些内容相关的属性同样需要定义在 CSS 样式的花括号里面。 CSS 支持的内容相关的属性有： include-source：该属性的值应为 url(url)，插入绝对或相对 URL 地址所对应的文档。 content：核心，该属性的值可以是字符串、url(url)、attr(alt)、counter(name)、counter(name，list-style-type)、open-quote、close-quote 等格式。该属性用于向指定元素之前或之后插入指定内容。 quotes：该属性用于为 content 属性定义 open-quote 和 close-quote，该属性的值可以是两个以空格分隔的字符串，其中前面的字符串是 open-quote，后面的字符串是 close-quote。 counter-increment：该属性用于定义一个计数器。该属性的值就是所定义的计数器的名称。 counter-reset：该属性用于对指定的计数值复位。 插入图像content 属性的值除了支持普通字符串之外，还可以使用 url(url) 格式的值，用于插入图像。 只插入部分元素有些时候，并不需要为元素的前、后插入内容，只需要向部分元素的前、后插入内容即可。可以在使用 :before、:after 伪元素选择器之前使用更严格的 CSS 选择器。 配合 quotes 属性执行插入使用 quotes 属性可以定义 open-quote 和 close-quote，然后就可以在 content 属性中应用 quotes 属性所定义的 open-quote 和 close-quote。 配合 counter-increment 属性添加编号使用自定义编号添加多级编号伪类选择器伪类选择器主要用于对已有选择器做进一步的 限制，对已有选择器能匹配的元素做进一步的过滤。CSS 提供的伪类选择器主要分为 3 类： 结构性伪类选择器结构性伪类选择器指的是根据 HTML 元素之间的结构关键进行筛选的伪类选择器，主要有如下几个： Selector:root：匹配文档的根元素，在 HTML 文档中，跟元素永远是 &lt;html../&gt; 元素。 Selector:first-child：匹配符合 Selector 选择器，而且必须是其父元素的第一个子节点的元素。 Selector:last-child：匹配符合 Selector 选择器，而且必须是其父元素的最后一个子节点的元素。 Selector:nth-child(n)：匹配符合 Selector 选择器，而且必须是其父元素的第 n 个子节点的元素。 Selector:nth-last-child(n)：匹配符合 Selector 选择器，而且必须是其父元素的倒数第 n 个子节点的元素。 Selector:only-child：匹配符合 Selector 选择器，而且必须是其父元素的唯一子节点的元素。 Selector:first-of-type：要求匹配符合 Selector 选择器，而且是与它同类型、同级的兄弟元素中的第一个元素。 Selector:last-of-type：要求匹配符合 Selector 选择器，而且是与它同类型、同级的兄弟元素中的最后一个元素。 Selector:nth-of-type(n)：要求匹配符合 Selector 选择器，而且是与它同类型、同级的兄弟元素中的第 n 个元素。 Selector:nth-last-of-type(n)：要求匹配符合 Selector 选择器，而且是与它同类型、同级的兄弟元素中的倒数第 n 个元素。 Selector:only-of-type：要求匹配符合 Selector 选择器，而且是与它同类型、同级的兄弟元素中的唯一一个元素。 Selector:empty：匹配符合 Selector 选择器，而且其内部没有任何子元素(包括文本节点)的元素。 上面这些伪类选择器中，前面的 Selector 选择器可以省略，如果省略了该选择器，则 Selector 将不作为匹配条件。 :root 伪类选择器用于匹配 HTML 文档的根元素，根元素只能是 &lt;html…/&gt; 元素。HTML 文档的根元素和 &lt;body…/&gt; 元素表示的范围是不同的。根元素的范围更大，如果没有显式为根元素指定样式，那么 &lt;body…/&gt; 元素的样式将会对整个文档起作用。 :first-child、:last-child、:nth-child、:nth-last-child、:only-child 这组伪类选择器依次要求匹配该选择器的元素必须是其父元素的第一个子节点、最后一个子节点、第 n 个子节点、倒数第 n 个子节点、唯一的子节点。 对于 :nth-child、:nth-last-child 两个伪类选择器，它们的功能更多： Selector:nth-child(odd/event)：匹配符合 Selector 选择器，而且必须是其父元素的第奇数个/偶数个子节点的元素。 Selector:nth-last-child(odd/event)：匹配符合 Selector 选择器，而且必须是其父元素的倒数第奇数个/偶数个子节点的元素。 Selector:nth-child(xn+y)：匹配符合 Selector 选择器，而且必须是其父元素的第 xn+y 个子节点的元素。 Selector:nth-last-child(xn+y)：匹配符合 Selector 选择器，而且必须是其父元素的倒数第 xn+y 个子节点的元素。 :first-of-type、:last-of-type、:nth-of-type、:nth-last-of-type、:only-of-type 这组伪类选择器并不要求它们是其父元素的第一个、最后一个、第 n 个、倒数第 n 个、唯一一个元素。这组伪类选择器只要求它们是与其有共同类型、同级元素的第一个、最后一个、第 n 个、倒数第 n 个、唯一一个元素。 :nth-of-type、:nth-of-last-type 的用法跟 :nth-child、:nth-last-child 类似。 UI 元素状态伪类选择器UI 元素状态伪类选择器主要用于根据 UI 元素的状态进行筛选。有如下几个： Selector:link：匹配 Selector 选择器且未被访问前的元素(通常只能是超链接)。 Selector:visited：匹配 Selector 选择器且已被访问过的元素(通常只能是超链接)。 Selector:active：匹配 Selector 选择器且处于被用户激活(在鼠标点击与释放之间的事件)状态的元素。 Selector:hover：匹配 Selector 选择器且处于鼠标悬停状态下的元素。 Selector:focus：匹配 Selector 选择器且已经得到焦点的元素。 Selector:enabled：匹配 Selector 选择器且当前处于可用状态的元素。 Selector:disabled：匹配 Selector 选择器且当前处于不可用状态的元素。 Selector:checked：匹配 Selector 选择器且当前处于选中状态的元素。 Selector:default：匹配 Selector 选择器且页面打开时处于选中状态的元素。 Selector:read-only：匹配 Selector 选择器且处于只读状态的元素。 Selector:read-write：匹配 Selector 选择器且处于读写状态的元素。 Selector::selection：匹配 Selector 选择器的元素中当前被选中的内容。 上面这些伪类选择器中，前面的 Selector 选择器可以省略，如果省略了该选择器，则 Selector 将不作为匹配条件。而且 ::selection 选择器前面有两个冒号。 浏览器专属的属性有些浏览器会有专属的自行扩展的 CSS 属性，可以在 CSS 属性前增加各自的浏览器前缀，来让这些浏览器识别这些专属属性。 :not 和 :targetCSS3 新增了两个特殊的伪类选择器： Selector:target：匹配符合 Selector 选择器且必须是命名锚点目标的元素。 Selector1:not(Selector2)：匹配符合 Selector1 选择器，但不符合 Selector2 选择器的元素，相当于用 Selector1 减去 Selector2。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC-国际化]]></title>
    <url>%2F2018%2F04%2F12%2FSpringMVC%2FSpringMVC-%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[SpringMVC 的国际化按如下步骤进行： 给系统加载国际化资源文件。 输出国际化。SpringMVC 输出国际化消息有两种方式：① 在视图页面上输出国际化消息，需要使用 SpringMVC 的标签库；② 在 Controller 的处理方法中输出国际化消息，需要使用 org.springframework.web.servlet.support.RequestContext 的 getMessage() 方法来完成。 messageSource在 SpringMVC 中，并不直接使用 ResourceBundle，而是利用 messageSource bean 告诉 SpringMVC 要将属性文件保存在哪里：1234567&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;message&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; localeResolver当用户选择语言区域时，最常用的方法是通过读取用户浏览器的 accept-language 标题值。除此之外还可以读取 HttpSession 或者 Cookie。 SpringMVC 提供了一个语言区域解析器接口 LocaleResolver，有如下实现类： AcceptHeaderLocaleResolver：默认解析器。 SessionLocaleResolver CookieLocaleResolver message 标签在 SpringMVC 中显示本地化消息通常使用 Spring 的 message 标签。1&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt; SessionLocaleResolver 国际化SessionLocaleResolver 不是默认的语言区域解析器，需要对其进行显式配置。其作用是从 HttpSession 作用域中获取用户所设置的语言区域，来确定使用哪个 Locale。123456&lt;mvc:interceptors&gt; &lt;!-- 国际化操作拦截器如果采用基于 Session/Cookie 则必须配置 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;/&gt;&lt;/mvc:interceptors&gt;&lt;!-- SessionLocaleResolver 配置 --&gt;&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.SessionLocaleResolver&quot;/&gt; 设置语言环境:12Locale locale=new Locale(&quot;zh&quot;,&quot;CN&quot;);request.getSession().setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME,locale); CookieLocaleResolver 国际化123456&lt;mvc:interceptors&gt; &lt;!-- 国际化操作拦截器如果采用基于 Session/Cookie 则必须配置 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;/&gt;&lt;/mvc:interceptors&gt;&lt;!-- SessionLocaleResolver 配置 --&gt;&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;/&gt; 设置语言环境：12Locale locale=new Locale(&quot;zh&quot;,&quot;CN&quot;);(new CookieLocaleResolver()).setLocale(request,response,locale);]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC-数据校验]]></title>
    <url>%2F2018%2F04%2F12%2FSpringMVC%2FSpringMVC-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[数据校验是所有 Web 应用必须处理的问题。应用程序必须能正常处理 View 层接收的各种数据，通常的做法是遇到异常输入时应用程序直接返回，提示用户必须重新输入。 输入校验分为客户端校验和服务器端校验： 客户端校验 主要是过滤正常用户的误操作，通常通过 JavaScript 代码完成。 服务器端校验 是整个应用阻止非法数据的最后防线，主要通过在应用中编码实现。 SpringMVC 提供了两种方式来验证输入：一种是 Spring 自带的 Validation 校验框架；另一种是利用 JSR 303(Java验证规范) 实现校验功能。 Spring 的 Validation 校验框架Spring 在进行数据绑定时，可以同时调用校验框架来完成数据校验工作。Spring 的校验框架在 org.springframework.validation 包中，其中重要的接口和类如下： Valiator：最重要的接口。包含两个方法： 12boolean supports(Class&lt;?&gt; clazz) - 该校验器能够对 clazz 类型的对象进行校验。void validate(Object target,Errors errors) - 对目标类 target 进行校验，并将校验错误记录在 errors 当中。 Errors：Spring 用来存放错误信息的接口。 ValidationUtils：Spring 提供的一个关于校验的工具类。它提供了多个给 Errors 对象保持错误的方法。 LocalValidatorFactoryBean：位于 org.springframework.validation.beanvalidation 包中，该类既实现了 Spring 的 Validator 接口，也实现了 JSR303 的Validator 接口，只有在 Spring 容器中定义一个 LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean 中。 验证器作用于 object 级别，用来决定某一个对象中的所有 field 是否均是有效的，以及是否遵循某些规则。 如果一个应用程序即使用了 Formatter，又使用了 validator(验证器)，那么，它们的事件顺序是这样的：在调用 Controller 期间，将会有一个或者多个 Formatter，试图将输入字符串转换成实体类对象的 field 值，一旦格式化成功，验证器就会介入。 （待补充） JSR303 校验JSR303 是 Java 为 Bean 数据合法性校验所提供的一个标准规范，叫做 Bean Valiadation。 Bean Validation 为 JavaBean 验证定义了相应的元数据类型和 API。在应用程序中，通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标注的验证接口对 Bean 进行验证。Bean Validation 是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回。 JSR303 是一个规范，它的核心接口是 javax.validation.Validator，该接口根据目标对象类中所标注的校验注解进行数据校验，并得到校验结果。JSR 303 目前有两个实现，第一个实现是 Hibernate Validator，第二个实现是 Apache bval。 JSR 303 中定义了一套可标注在成员变量、属性方法上的校验注解： Hibernate Valiadator 是 JSR 303 的一个参考实现，处理支持所有标准的校验注解之外，它还扩展了注解： 示范：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354**************************&lt;form:form modelAttribute=&quot;admin&quot; method=&quot;post&quot; action=&quot;/adminLogin&quot;&gt; &lt;div class=&quot;login-form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;form:input type=&quot;text&quot; path=&quot;name&quot; class=&quot;form-control login-field&quot; id=&quot;login-name&quot; name=&quot;login-name&quot;/&gt; &lt;form:errors path=&quot;name&quot; cssStyle=&quot;color:red&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;form:input type=&quot;password&quot; path=&quot;pwd&quot; class=&quot;form-control login-field&quot; id=&quot;login-pass&quot; name=&quot;login-pwd&quot;/&gt; &lt;form:errors path=&quot;pwd&quot; cssStyle=&quot;color: red&quot;/&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary btn-lg btn-block&quot; value=&quot;登录&quot;/&gt; &lt;a class=&quot;login-link&quot; href=&quot;#&quot;&gt;Lost your password?&lt;/a&gt; &lt;/div&gt; &lt;/form:form&gt;****************************************************public class Admin&#123; private Integer id; @NotBlank(message = &quot;登录名不能为空&quot;) private String name; @NotBlank(message = &quot;密码不能为空&quot;) private String pwd; public Admin() &#123; &#125;&#125;****************************************************@RequestMapping(value = &quot;/adminLogin&quot;) public String adminLogin(@Valid @ModelAttribute Admin admin, Errors errors, HttpSession httpSession) &#123; if (errors.hasErrors()) &#123; return &quot;loginPage&quot;; &#125; Admin adminLogin = biz.adminLogin(admin.getName(), admin.getPwd()); if (adminLogin != null) &#123; //登录成功 httpSession.setAttribute(&quot;admin&quot;, adminLogin); return &quot;/index&quot;; &#125; else //登录失败 return &quot;redirect:/loginPage&quot;; &#125;**************************]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC-文件上传下载]]></title>
    <url>%2F2018%2F04%2F12%2FSpringMVC%2FSpringMVC-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[文件上传为了能上传文件，必须将表单的 method 设置为 POST，并将 enctype 设置为 multipart/form-data。这样浏览器会采用二进制流的方式来处理表单数据。 有两种方式来进行文件上传： 利用 Servlet 3.0 及更高版本的支持，但这种上传需要在 Servlet 中完成。 SpringMVC 使用 Apache Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResolver。 在 HTML5之前，想要上传多个文件，就必须使用多个文件 input 元素。但是在 HTML5 中编写以下任意一行代码，即可生成一个按钮选择多个文件：1234&gt;&lt;input type=&quot;file&quot; name=&quot;fileName&quot; multiple/&gt;&gt;&lt;input type=&quot;file&quot; name=&quot;fileName&quot; multiple=&quot;multiple&quot;/&gt;&gt;&lt;input type=&quot;file&quot; name=&quot;fileName&quot; multiple=&quot;&quot;/&gt;&gt; 使用 SpringMVC 提供文件上传支持在负责上传的表单设置编码为 “multipart/form-data”：1234&lt;form action=&quot;upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; 在请求方法中：123456789101112131415161718192021222324@RequestMapping(value = &quot;/uploadFiles&quot;) public String uploadFile(HttpServletRequest request, @RequestParam(&quot;files&quot;) MultipartFile file) throws IOException &#123; //如果上传文件非空,写入上传路径 if (!file.isEmpty()) &#123; //获取保存路径 String savePath = request.getSession().getServletContext().getRealPath(&quot;/uploadFiles/&quot;); //上传文件名 String uploadFileName = file.getOriginalFilename(); File filepath=new File(savePath,uploadFileName); if (!filepath.getParentFile().exists()) &#123; filepath.getParentFile().mkdir(); &#125; file.transferTo(new File(savePath+File.separator+uploadFileName)); request.setAttribute(&quot;message&quot;,&quot;文件上传成功&quot;); &#125; else &#123; request.setAttribute(&quot;message&quot;,&quot;文件上传异常&quot;); &#125; return &quot;fileUpload&quot;; &#125; 要使用 SpringMVC 的文件上传功能，还需要在配置文件中配置 MultipartResolver：12345678910&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 上传文件大小上限，单位为字节 --&gt; &lt;property name=&quot;maxUploadSize&quot;&gt; &lt;value&gt;10485760&lt;/value&gt; &lt;/property&gt; &lt;!-- 请求的编码格式，必须和 JSP 的 pageEncoding 属性一致，以便正确读取表单的内容，默认为 ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot;&gt; &lt;value&gt;UTF-8&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 注意，SpringMVC 自带的文件上传功能依赖于 Apache Commons FileUpload 的组件，所以需要 commons-fileupload-x.y.jar 和 commons-io-x.y.jar。 MultipartFile 对象中的常用方法有： byte[] getBytes()：获取文件数据。 String getContentType()：获取文件 MIME 类型，如 image/jpeg 等。 InputStream getInputStream()：获取文件流。 String getName()：获取表单中文件组件的名字。 String getOriginalFilename()：获取上传文件的原名。 long getSiez()：获取文件的字节大小，单位为 byte。 boolean isEmpty()：是否有上传的文件。 void transferTo(File dest)：将上传文件保存到一个目标文件中。 利用 Servlet 3 及更高版本上传文件利用 Servlet3 进行文件上传，需要在 web.xml 中对 servlet 元素进行改造，12345678&lt;servlet&gt; ..... &lt;multipart-config&gt; &lt;max-file-size&gt;20848820&lt;/max-file-size&gt; &lt;max-request-size&gt;418018841&lt;/max-request-size&gt; &lt;file-size-threshold&gt;1048576&lt;/file-size-threshold&gt; &lt;/multipart-config&gt;&lt;/servlet&gt; @MultipartConfig 有如下可选属性： maxFileSize：上传文件的最大容量，默认值为 -1，表示没有限制。大于指定值的文件将会被拒绝。 maxRequestSize：表示多部分 HTTP 请求允许的最大容量，默认值为 -1，表示没有限制。 location：表示在 Part 调用 write 方法时，要将已上传的文件保存到硬盘中的位置。 fileSizeThreshold：上传文件超出这个容量界限时，会被写入硬盘。 此外，还需要在 SpringMVC 配置文件中使用一个不同的多部分解析器：12&lt;!-- 设置一个多部分解析器来进行基于 Servlet3 的文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;/&gt; 客户端上传HTML5 在其 DOM 中添加了一个 File API，用于客户端文件上传。（待补充） 文件下载对于一些保存在应用程序目录外，或者是保存在某一个数据库中，或者有时需要控制它的访问权限，防止其他网站交叉引用的资源，可以通过编程来发送。通过编程进行的文件下载，可以有选择地将文件发送到浏览器。 通过编程把一个文件发送到浏览器，需要在控制器完成以下工作： 对请求处理方法使用 void 返回类型，并在方法中添加 HTTPServletResponse 参数。 将响应的内容类型设置为文件的内容类型，例如 response.setContentType(&quot;application/pdf&quot;)，如果不清楚内容类型，并且希望浏览器始终显示Save As(另存为) 对话框，可以将 ContentType 设置为 APPLICATION_OCTET_STREAM 。 添加一个名为 Content-Disposition 的 HTTP 响应标题，并赋值 attachment；filename=fileName，这里 fileName 默认是文件名，通常与文件同名。 以下是一个隐藏资源的示例，12345678910111213141516171819202122232425262728293031@RequestMapping(value = &quot;/resource_download&quot;) public void downloadResource(HttpServletRequest request, HttpServletResponse response) &#123; String dataDir = request.getSession().getServletContext().getRealPath(&quot;/WEB-INF/data&quot;); String fileName = &quot;excel.pdf&quot;; File file = new File(dataDir, fileName); if (file.exists()) &#123; response.setContentType(&quot;application/octet-stream&quot;); response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + fileName); byte[] buffer = new byte[1024]; try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)) ) &#123; OutputStream outputStream = response.getOutputStream(); int i = bis.read(buffer); while (i != -1) &#123; outputStream.write(buffer, 0, i); i = bis.read(buffer); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-基本使用]]></title>
    <url>%2F2018%2F04%2F10%2FMyBatis%2FMyBatis-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MyBatis 作为持久层框架，其主要思想是将程序中的大量 SQL 语句剥离出来，配置在配置文件中，以实现 SQL 的灵活配置。这样做的好处是将 SQL 与程序代码分离，做到可以在不修改程序代码的情况下，直接在配置文件中修改 SQL。 使用 MyBatis 进行持久化操作，通常有如下操作步骤： 开发实体类 POJO 和编写持久化操作的 Mapper.xml，在 Mapper.xml 中定义要执行的 SQL 语句； 获取 SqlSessionFactory； 获取 SqlSession； 用面向对象的方式操作数据库； 关闭事务，关闭 SqlSession； MyBatis 的初始化要经过以下几个步骤： 调用 SqlSessionFactoryBuilder 对象的 build(inputStream) 方法； SqlSessionFactoryBuilder 会根据输入流 inputStream 等信息创建 XMLConfigBuilder 对象； SqlSessionFactoryBuilder 调用 XMLConfigBuilder 对象的 parse() 方法； XMLConfigBuilder 对象解析 XML 配置文件返回 Configuration 对象； SqlSessionFactoryBuilder 根据 Configuration 对象创建一个 DefaultSessionFactory 对象； SqlSessionFactoryBuilder 返回 DefaultSessionFactory 对象给客户端，供客户端使用。 创建 SqlSessionFactory 以及 获取 SqlSessin123456//读取 mybatis-config.xml 文件为输入流InputStream inputStream=Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);//初始化 mybatis,创建 SqlSessionFactory 类的实例SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream);//创建 SqlSession 实例SqlSession sqlSession=sqlSessionFactory.openSession(); 通过 XML 编写对应的 SQL 语句1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;mapper namespace=&quot;包名.UserMapper&quot;&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;org.fkit.domain.User&quot; userGeneratedKeys=&quot;true&quot;&gt; INSERT INTO TB_USER(name,sex,age) VALUES(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 通过 mapper 接口操作数据库MyBatis 官方手册建议通过 mapper 接口的代理对象访问 MyBatis，该对象关联了 SqlSession 对象，开发者可以通过该对象直接调用方法操作数据库。 Mapper 接口对象的类名必须和之前的 XML 文件中的 mapper 的 namespace 一致，而且方法名和参数也必须和 XML 文件中的 SQL 语句的 id 属性和 parameterType 属性一致。123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;mapper namespace=&quot;包名.PersonMapper&quot;&gt; &lt;select id=&quot;selectPersonById&quot; parameterType=&quot;int&quot; ...&gt;&lt;/mapper&gt; 1234public interface PersonMapper&#123; Person selectPersonById(Integer id);&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-简介]]></title>
    <url>%2F2018%2F04%2F10%2FSpring%2FSpring-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[先来了解关于 Spring 的几个基本概念： 非侵入式所谓非侵入式，指 Spring 框架的 API 不会在业务逻辑上出现。 容器Spring 提供容器功能，容器可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过写一个配置文件(通常是 XML 文件)，在上面定义对象的名字、是否单例模式，以及设置与其他对象的依赖关系。在容器启动后，这些对象就被实例化，可以直接使用，而且依赖关系也建立好了。 IOC提供一个控制反转容器。”控制” 就是指对对象的创建、维护、销毁等生命周期的控制，这个过程一般是由我们的程序去主动控制的，如使用 new 关键字去创建一个对象(创建)，在使用过程中保持引用(维护)，在失去全部引用后由GC去回收对象(销毁)。“反转” 就是指对对象的创建、维护、销毁等生命周期的控制由程序控制改为由IOC容器控制，需要某个对象时就直接通过名字去IOC容器中获取。 依赖注入依赖注入是处理此类情景的：接管对象的创建工作，并将该对象的引用注入需要该对象的组件。由 Spring 框架为接口的实现，对象的创建进行注入。 AOP面向方便编程，将日志、安全、事务管理等服务或功能理解成一个 “方面”，从业务逻辑代码中剥离出来，实现复用。 此外，Spring 还可以实现对 JDBC 的封装和简化，提供事务管理功能，对 Hibernate 的整合，提供 MVC 解决方案，还有对 JNDI、mail 等服务进行了封装。 Bean 工厂的 ApplicationContextSpring IOC 的核心是 Bean 容器，BeanFactory 采用工厂模式，通过从 XML 配置文件中读取 JavaBean 的定义，实现 JavaBean 的创建、配置和管理。所以 BeanFactory 就是 “IOC容器”。而 ApplicationContext 扩展了 BeanFactory 容器并添加了对 国际化、资源访问、事件传播等方面的支持，成为 JavaEE 应用中首选的 IOC容器，可以在 Java App 和 Java Web 中应用。 ApplicationContext 的中文是”应用上下文”，它继承于 BeanFactory 接口，有三个常用的实现类： ClassPathXmlApplicationContext从类路径 ClassPath 中寻找指定的 XML 配置文件完成 ApplicationContext 的实例化工作： 12ApplicationContext context=new ClassPathXmlApplicationContext(String configLocation);//configLocation 参数指定 Spring 配置文件的名称和位置 FileSystemXmlApplicationContext从指定的文件系统路径中寻找指定的 XML 配置文件来进行容器的实例化。 XmlWebApplicationContext从 Web 应用中寻找指定的 XML 配置文件进行容器的实例化。 在 Java 项目中通过 ClassPathXmlApplicationContext 类手工实例化容器，但是在 Web 项目中就不能这样做。Web 项目的启动是由相应的 Web 服务器负责的。因此，在 Web 项目中 ApplicationContext 容器的实例化工作最好交给 Web 服务器来完成，Spring 为此提供了如下两种方式： 基于 ContextLoaderListener 实现在 web.xml 中添加如下代码： 123456789&lt;!-- 指定 Spring 配置文件的位置，多个配置文件以逗号分隔 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 指定以 Listener 方式启动 Spring 容器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 基于 ContextLoaderServlet 实现在 web.xml 中添加如下代码： 1234567891011&lt;!-- 指定 Spring 配置文件的位置，多个配置文件以逗号分隔 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 指定以 Servlet 方式启动 Spring 容器 --&gt;&lt;srevlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; Bean 的作用域容器创建 Bean 后，需要了解 Bean 在容器中是如何在不同作用域下工作的。 Spring 为 Bean 定义了 5 种作用域： singleton：在每个 Spring IOC 容器中，一个 Bean 定义对应一个对象实例。 prototype：一个 Bean 定义对应多个对象实例。 request：在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例，而对于不同的用户请求，会返回不同的实例。 session：在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对于不同的 HTTP Session 请求，会返回不同的实例。 global session：在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate-使用数据库连接池]]></title>
    <url>%2F2018%2F04%2F10%2FHibernate%2FHibernate-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[Hibernate 配置连接池的方式： 使用 Hibernate 自带的连接池。 使用配置文件指定的数据库连接池。 从容器中获取连接池(如：Tomcat)。 使用配置文件指定的连接池 C3P0、Proxool使用 C3P0首先引入 c3p0 的jar包，然后在 Hibernate 的配置文件 hibernate.cfg.xml 中进行配置：12345678910111213&lt;!--C3P0配置 --&gt;&lt;property name=&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt;&lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;20&lt;/property&gt;&lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;5&lt;/property&gt;&lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;120&lt;/property&gt;&lt;property name=&quot;automaticTestTable&quot;&gt;Test&lt;/property&gt;&lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;100&lt;/property&gt;&lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;120&lt;/property&gt;&lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;1&lt;/property&gt;&lt;property name=&quot;c3p0.testConnectionOnCheckout&quot;&gt;true&lt;/property&gt;&lt;property name=&quot;c3p0.idleConnectionTestPeriod&quot;&gt;18000&lt;/property&gt;&lt;property name=&quot;c3p0.maxIdleTime&quot;&gt;25000&lt;/property&gt;&lt;property name=&quot;c3p0.idle_test_period&quot;&gt;120&lt;/property&gt; 利用 JNDI 技术从 Tomcat 中获取数据源数据源(DataSource)对象由 Web 容器(Tomcat)提供，此时利用 JNDI 获得数据源对象。可以把它理解为一种将对象和名字捆绑的技术，对象工厂负责生产出对象，这些对象都与唯一的名字绑在一起，外部资源可以通过名字获得某对象的引用。 在 javax.naming 的包中提供 Context 接口，该接口提供了两种常用方法： void bind(String name,Object object)：该方法用于将名称绑定到对象，所有中间上下文和目标上下文都必须已经存在。 Object lookup(String name)：该方法用于检索指定的名字绑定的对象。如果 name 为空，则返回此上下文的一个新实例。以下代码可以获取名称为 jdbc/bookshop 的数据源对象：12Context context=new InitialContext();DataSource dataSource=(DataSource)context.lookup(&quot;java:comp/env/jdbc/bookshop&quot;); 其中 java:comp/env/ 为前缀，使用 lookup() 方法获取数据源对象后，可以使用 DataSource 对象的 getConnection() 方法获取数据库连接对象。1Connection con=dataSource.getConnection(); 配置数据源名称 配置 context.xml 文件在 Tomcat 根目录 \conf\context.xml文件中的&lt;Context&gt; 节点中添加 &lt;Resource&gt; 节点,内容如下: 1234567891011&lt;Resource name=&quot;jdbc/bookshop&quot; auth=&quot;Container&quot;type=&quot;javax.sql.DataSource&quot;maxActive=&quot;100&quot;maxIdle=&quot;30&quot;maxWait=&quot;10000&quot;username=&quot;root&quot;password=&quot;1234&quot;driverClassName=&quot;com.mysql.jdbc.Driver&quot;url=&quot;jdbc:mysql://localhost:3306/bookshop&quot; /&gt; 创建并配置web.xml文件在 web.xml 的 &lt;web-app&gt; 节点下添加 &lt;resource-ref&gt; 节点,代码如下 12345&lt;resource-ref&gt;&lt;description&gt;BookShop DataSource&lt;/description&gt;对应用资源的说明&lt;res-ref-name&gt;jdbc/bookshop&lt;/res-ref-name&gt;指定所应用资源的JNDI名字,对应于&lt;Resource&gt;节点的name属性&lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;指定所引用资源的类名字,对应于&lt;Resource&gt;节点的type属性&lt;res-auth&gt;Container&lt;/res-auth&gt;指定所应用资源的管理者,对应于&lt;Resource&gt;节点的auth属性 添加数据库驱动文件把 MySQL 的驱动程序复制到 Tomcat 根目录的 \lib 目录。 在 Hibernate 中使用数据库连接池]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 个人日常设置]]></title>
    <url>%2F2018%2F04%2F10%2FOthers%2FIDEA%E4%B8%AA%E4%BA%BA%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[设置花括号对齐方式IDEA 默认花括号跟方法名在同一行，如果想花括号另起一行对齐，可以这样做：12File -&gt; Setting -&gt; Editor -&gt; Code Style -&gt; Java在右边界面找到 **Wrapping and Braces** 取消 mybatis 的 xml 文件 sql 语句黄色高亮Editor -&gt; Inspections -&gt; SQL -&gt; SQL dialect detection 取消打勾 如果还对剩下的暗绿色高亮背景不顺眼，还可以在 Editor -&gt; Color Scheme -&gt; General 把 Code 选项的 Injected language fragment 选项的 Background 取消。 取消只有一行的方法体自动折叠File-&gt;Setting-&gt;Editor-&gt;General-&gt;Code Folding，把 one-line methods 打勾取消 Intellij IDEA 自动生成 serialVersionUIDSetting -&gt; Inspections -&gt; Serialization issues -&gt; Serializable class without ’serialVersionUID’]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2018%2F04%2F02%2F%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树(tree) 是非线性的数据结构，可用来描述有分支的结构。 树 具有以下特质： 存在一个特殊的节点，称为 树根(root)。 其余的节点分为 n&gt;=0 个互斥的集合，T1，T2，T3…Tn，且每个集合称为 子树。 树 的专有名词： 树根或根节点(root)：没有父节点的节点为根节点，如上图根节点为 A。 父节点(parent)：每一个节点的上层节点为父节点，如 B 的父节点为 A。 子节点(children)：每一个节点的下层节点为子节点，如 B 的子节点为 D，A 的子节点有 B，C。 兄弟节点(siblings)：有共同父节点的节点为兄弟节点，如 E ，F 的父节点均为 C，所以彼此为兄弟节点。 度(degree)：子树的个数为该节点的度，如 A 的度为 2，B 的度为 1。 终端节点或叶子节点(terminal node)：没有子节点的节点，即度为 0 的节点，例如 DEF 均为终端节点或叶子。 非终端节点(non-terminal node)：叶子以外的节点均为非终端节点，即度不为 0 的节点，如 ABC 均为非终端节点。 阶层或级(level)：树的层级，假设树根 A 为阶层1，B，C 节点即为阶层2，D，E，F即为阶层 3。 高度(height)：树的最大阶层，例如上图的树的最大高度为 3。 树林(forest)：树林是由 n 个互斥树的集合(n&gt;=0)，移去树根即为树林。例如此树形图中移去节点 A，则为包含二个树的树林。 祖先(ancestor)和子孙(descendent)：所谓祖先，是指从树根到该节点路径上所包含的节点，而子孙则是在该节点子树中的任一节点。例如 E 的祖先为 A、C，B的子孙为 D。 树的基本操作 初始化：创建一个空的树。 为指定节点添加子节点。 返回根节点。 返回指定节点(非根节点)的父节点。 返回指定节点(非叶子节点)的所有子节点。 返回指定节点(非叶子节点)的第 i 个子节点。 返回该树的深度。 返回指定节点的位置。 二叉树(Binary tree)二叉树 是一个度小于或等于2的树，且二叉树必须考虑到前后次序的关系。 建立二叉树必须遵守 “小于父节点的值放在左子节点，大于父节点的值放在右子节点” 的规则。可以确保左子树的值一定完全小于树根，右子树的值一定大于树根。 二叉树的基本性质 一棵非空二叉树的第 k 层上最多有 2k-1 个节点(k&gt;=1)。 一棵高度为 k 的二叉树中，最多有 2k-1 个节点，最少有 k 个节点。 对于一棵非空的二叉树，度为 0 的节点(即终端节点)总是比度为 2 的节点多一个，即如果终端节点数为 n0，度为 2 的节点数为 n0-1。 具有 n 个节点的完全二叉树的高度为 [log2n]+1。 对于具有 n 个节点的完全二叉树，如果按照从上至下和从左到右的顺序对二叉树中的所有节点从 1 开始编号，则对于任意的序号为 i 的节点，有：①如果 i &gt; 1，那么序号为 i 的节点的父节点的序号为 i/2；如果 i=1，那么序号为 i 的节点是根节点，无父节点。②如果 2i &lt;= n，那么序号为 i 的节点的左子节点的序号为 2i；如果 2i &gt; n，那么序号为 i 的节点无左子节点。③如果 2i+1 &lt;= n，那么序号为 i 的节点的右子节点的序号为 2i+1；如果 2i+1 &gt; n，那么序号为 i 的节点无右子节点。 满二叉树(Full binary tree)如果二叉树的高度为 h，树的节点树为 2h-1，h&gt;=0，则此树为 “满二叉树”。 完全二叉树(Complete binary tree)如果二叉树的高度为 h，所含的节点数小于 2h-1，但其节点的编号方式如同高度为 h 的满二叉树一样，从左到右，由上到下的顺序一一对应。对于完整二叉树而言，假设有 N 个节点，那么此完全二叉树的阶层(level) h 为 [log2(N+1)]。 歪斜树(skewed binary tree)当一个二叉树完全没有右节点或左节点时，对应的称为 左歪斜树 或 右歪斜树。 严格二叉树(strictly binary tree)如果二叉树的每个非终端节点均有非空的左右子树，则为严格二叉树。 二叉树存储方式数组表示法如果要使用一维数组来存储二叉树，首先将二叉树想象成一个满二叉树，而且第 k 个阶层具有 2k-1 个节点，并且依序存放在此一维数组中。如果愈姐今满二叉树，则愈节省空间，如果是歪斜树，则最浪费空间。另外要增删数据较麻烦，要重新建立二叉树。 链表表示法链表表示二叉树的好处是对节点的增删相当容易。 二叉树的遍历(Binary Tree Traversal)二叉树的遍历就是 “访问二叉树中所有的节点各一次”，并且在遍历后，将树中的数据转化为线性关系。 按照二叉树特性，一律由左向右，共有三种遍历方式，遍历方式一定是先左子树后右子树： 中序遍历(BAC，Inorder)：左子树 -&gt; 树根 -&gt; 右子树沿树的左子树一直往下，直到无法前进，后退回到父节点，再往右子树一直往下。如果右子树也走完了就退回上层的左节点，再重复 左、中、右 的顺序遍历。 前序遍历(ABC，Preorder)：树根 -&gt; 左子树 -&gt; 右子树前序遍历就是从根节点开始处理，根节点处理完往左子树走，直到无法前进再处理右子树。 后序遍历(BCA，Postorder)：左子树 -&gt; 右子树 -&gt; 树根后序遍历是把左子树的节点和右子树的节点都处理完才处理树根。 利用链表实现二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class BinaryTree&#123; private TreeNode rootNode; public TreeNode getRootNode() &#123; return rootNode; &#125; /** * 根据给定的数组进行二叉树的初始化 * * @param data 指定数组 */ public BinaryTree(int[] data) &#123; for (int i : data) &#123; add(i); &#125; &#125; /** * 把数据插入二叉树 * * @param data */ public void add(int data) &#123; TreeNode newNode = new TreeNode(data); TreeNode current = rootNode; if (rootNode == null) &#123; rootNode = newNode; &#125; else &#123; while (true) &#123; if (data &lt; current.data)//小于就放在左子树 &#123; if (current.leftNode == null) &#123; current.leftNode = newNode; return; &#125; else &#123; current = current.leftNode; &#125; &#125; else if (data &gt; current.data)//大于就放在右子树 &#123; if (current.rightNode == null) &#123; current.rightNode = newNode; return; &#125; else &#123; current = current.rightNode; &#125; &#125; &#125; &#125; &#125; /** * 中序遍历 * * @param node 二叉树的根节点 root */ public void inOrder(TreeNode node) &#123; if (node != null) &#123; inOrder(node.leftNode); System.out.print("[" + node.data + "]" + " "); inOrder(node.rightNode); &#125; &#125; /** * 前序遍历 * * @param node 二叉树的根节点 root */ public void preOrder(TreeNode node) &#123; if (node != null) &#123; System.out.print("[" + node.data + "]" + " "); preOrder(node.leftNode); preOrder(node.rightNode); &#125; &#125; /** * 后序遍历 * * @param node 二叉树的根节点 root */ public void postOrder(TreeNode node) &#123; if (node != null) &#123; postOrder(node.leftNode); postOrder(node.rightNode); System.out.print("[" + node.data + "]" + " "); &#125; &#125; class TreeNode &#123; int data; TreeNode leftNode; TreeNode rightNode; public TreeNode(int data) &#123; this.data = data; this.leftNode = null; this.rightNode = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate5 版本 SessionFactory]]></title>
    <url>%2F2018%2F04%2F02%2FHibernate%2F%E5%9C%A8Hibernate5%E4%B8%AD%E5%88%9B%E5%BB%BASessionFactory%2F</url>
    <content type="text"><![CDATA[Hibernate4 版本中创建 SessionFactory1234567//Configuration 就是代表着 hibernate 的那个 xml 配置文件对象，如果 configure 方法中没有参数的话，默认是就是hibernate.cfg.xml。Configuration conf = new Configuration().configure();//服务注册，这是使用创建者模式，根据配置文件中的配置字段来构建注册服务（这应该是 hibernate 架构中注册服务的通用流程）ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).build();//使用实例化好了的注册服务，使用Configuration中的工厂模式实例化了SessionFactory.SessionFactory sf = conf.buildSessionFactory(serviceRegistry); Hibernate5版本中创建 SessionFactory1234567//V5版本不再需要 configure 对象了，直接使用创建者模式构建出了标准服务注册对象StandardServiceRegistry standardRegistry = new StandardServiceRegistryBuilder().configure().build();//这个对象 metadata 对象应该扮演了一个万金油的角色，使用以上的注册对象作为入参构建这个对象Metadata metadata = new MetadataSources(standardRegistry).getMetadataBuilder().applyImplicitNamingStrategy(ImplicitNamingStrategyComponentPathImpl.INSTANCE).build();//最后由这个 metadata 使用构建出 sessionFactorySessionFactory sessionFactory = metadata.getSessionFactoryBuilder().build(); 范例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HibernateSessionFactory&#123; private static final ThreadLocal&lt;Session&gt; sessionThreadLocal = new ThreadLocal&lt;&gt;(); private static SessionFactory sessionFactory; static &#123; StandardServiceRegistry standardServiceRegistry = new StandardServiceRegistryBuilder().configure().build(); Metadata metadata = new MetadataSources(standardServiceRegistry).getMetadataBuilder().applyImplicitNamingStrategy(ImplicitNamingStrategyComponentPathImpl.INSTANCE).build(); sessionFactory = metadata.getSessionFactoryBuilder().build(); &#125; public static SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; //重建SessionFactory private static void rebuildSessionFactory() &#123; synchronized (sessionFactory) &#123; StandardServiceRegistry standardServiceRegistry = new StandardServiceRegistryBuilder().configure().build(); Metadata metadata = new MetadataSources(standardServiceRegistry).getMetadataBuilder().applyImplicitNamingStrategy(ImplicitNamingStrategyComponentPathImpl.INSTANCE).build(); sessionFactory = metadata.getSessionFactoryBuilder().build(); &#125; &#125; //获得Session对象 public static Session getSession() &#123; Session session = sessionThreadLocal.get(); if (session == null || !session.isOpen()) &#123; if (sessionFactory == null) &#123; rebuildSessionFactory(); &#125; session = (sessionFactory != null) ? sessionFactory.openSession() : null; sessionThreadLocal.set(session); &#125; return session; &#125; //关闭Session对象 public static void closeSession() &#123; Session session = sessionThreadLocal.get(); sessionThreadLocal.set(null); if (session != null &amp;&amp; session.isOpen()) &#123; session.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC-简介]]></title>
    <url>%2F2018%2F04%2F01%2FSpringMVC%2FSpringMVC-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Model2 是基于 MVC 架构的设计模式。Servlet 作为前端控制器，负责接收客户端发送的请求。在 Servlet 中只包含控制逻辑和简单的前端处理；然后，调用后端 JavaBean 来完成实际的逻辑处理；最后，将其转发到相应的 JSP 页面来处理显式逻辑。 SpringMVC 的 DispatcherServlet在 MVC 框架中，都包含一个用于调度控制的 Servlet。Spring MVC 提供了一个 org.springframework.web.servlet.DispatcherServlet 的 Servlet 充当前端控制器，所有的请求驱动都围绕这个 DispatcherServlet 来分派请求。 DispatcherServlet 是一个继承自 HttpServlet 的 Servlet 类，使用时需要把它配置在 web.xml 文件中：123456789101112131415&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet&gt; &lt;servlet-calss&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- (可选)指定SpringMVC 的配置文件位置信息 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLoaction&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- DispatcherServlet 的映射声明 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet&gt; &lt;url-patter&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; DispatcherServlet 在 Web 应用程序启动时立即加载，并需要一个 SpringMVC 的配置文件(默认名称为Dispatcher-servlet.xml)，默认会去 WEB-INF 文件夹下查找对应的 [servlet-name]-servlet.xml 文件。也可以把 SpringMVC 的配置文件放到应用程序文件夹中的任何地方，用 &lt;init-param&gt; 子元素进行描述。 当 Dispatcher-servlet.xml 配置文件被解析后，会创建一个 WebApplicationContext 容器对象，也称为上下文环境。WebApplicationContext 继承自 ApplicationContext 容器。有了 WebApplicationContext 容器，就可以使用 Spring 的 IOC、AOP 等其他功能。 SpringMVC 应用的开发步骤： 在 web.xml 文件中定义前端控制器 DispatcherServlet 来拦截用户请求。 如果需要以 POST 的方式提交请求，则定义包含表单数据的 JSP 页面。如果仅仅只是以 GET 方式发送请求，则无须经过这一步。 定义处理用户请求的 Handle 类。这一步是最重要的，在这里前端控制器负责接收请求，并将请求分发给对应的 Handle，即实现 Controller 接口的 Java 类，而该 Java 类负责调用后台业务逻辑代码来处理请求。 控制器实际上由两部分组成，即拦截所有用户请求和处理请求的通用代码都由前端控制器 DispatcherServlet 完成，而实际的业务控制(诸如调用后台业务逻辑代码，返回处理结果等)则由 Controller 类完成。 通过注解配置 Handle。即配置哪个请求对应哪个 Controller 进行处理，使用注解 @Controller。 编写视图资源。当 Controller 类处理完用户请求后，通常会返回一个 ModelAndView 对象，该对象中包含视图名称或视图名加模型。 SpringMVC 的执行流程 用户向服务器发送请求，请求被 SpringMVC 的前端控制器 DispatcherServlet 截获。 DispatcherServlet 对请求 URL 进行解析，得到 U.RI。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象，包括 Handler 对象以及 Handler 对象对应的拦截器，这些对象会被封装到一个 HandlerExceptionChain 对象中返回。 DispatcherServlet 根据获得的 Handler，选择一个合适的 HandlerAdapter。HandlerAdapter 会被用于处理多种 Handler，调用 Handler 实际处理请求的方法，例如 hello() 方法。 提取请求方法中的模型数据，开始执行 Handler(Controller)。在填充 Handler 的入参过程中，根据配置，SpringMVC 会做一些额外的工作： 消息转换：将请求消息(如 JSON、XML 等数据)转换成一个对象，将对象转换为指定的响应信息。 数据转换：对请求消息进行数据转换，如 String 转换成 Integer、Double 等。 数据格式化：对请求消息进行数据格式化，如将字符串转换成格式化数字或格式化日期等。 数据验证：验证数据的有效性(长度、格式等)，验证结果存储到 BindingResult 或 Error 中。 Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象，ModelAndView对象中应该包含视图名或视图名加模型。 根据返回的 ModelAndView 对象，选择一个合适的 ViewResolver(视图解析器)返回给 DispatcherServlet。 ViewResolver 结合 Model 和 View 来渲染视图。 将视图渲染结果返回给客户端。]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5-面向对象（上）]]></title>
    <url>%2F2018%2F03%2F26%2FJava%2F5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[封装封装 指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象中的信息，而是通过该类所提供的方法来实习对内部信息的操作和访问。实现以下目的： 隐藏类的实现细节。 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问。 可进行数据检查，从而有利于包装对象的完整性。 便于修改。 继承继承 是一种实现代码复用的手段。Java 的类只允许单继承，每个子类只能有一个直接父类。 方法覆盖 要遵循 “两同两小一大” 规则，”两同” 即方法名相同、形参列表相同；’’两小” 即子类方法返回值类型要比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应该比父类方法声明抛出的异常类更小或相等；”一大” 指子类方法的访问权限应该比父类方法的访问权限更大或相等。 子类中定义与父类中同名的实例变量不会完全覆盖父类中定义的实例变量，它只是简单地隐藏了父类中的实例变量，可以通过 super 作为限定来进行调用父类的实例变量。 当创建一个子类时，系统不仅会为该类中定义的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存，即使子类定义了与父类中同名的实例变量。 多态多态 是指在程序运行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 通俗的讲，只通过父类就能够引用不同的子类，或者通过接口就能引用不同的实现类，这就是多态。只有在运行的时候才能知道引用变量所指向的具体实例对象。 对于 A a = new B()，在编译时 a 的类型为 A，因此编译器将不允许调用 B 中没有在 A 中定义的方法。另一方面，运行时 a 的实际类型是 B。这就是多态的本质。如果 B 覆盖了 A 中的方法(比如，一个名叫 play() 的方法)，那么调用 a.play() 将导致调用 B (而不是 A) 中 play() 的实现。多态使得在调用方法时对象(指 a 引用的那个)能决定选择哪一个方法实现(或是 A 中的那个，或是 B 中的那个)。 通过引用变量来访问其包含的实例变量时，系统总是试图访问它编译时类型所定义的成员变量，而不是它运行时类型所定义的成员变量。 初始化顺序父类静态变量 -&gt; 父类静态代码块 -&gt; 子类静态变量 -&gt; 子类静态代码块 -&gt; 父类非静态变量 -&gt; 父类非静态代码块 -&gt; 父类构造器 -&gt; 子类非静态变量 -&gt; 子类非静态代码块 -&gt; 子类构造器 this 和 super一个方法含有 隐式参数(即调用该方法的对象) 和 显式参数(方法的形参列表)。 this 有两种用法： 关键字 this 引用方法的隐式参数，即调用该方法的对象。 如果构造器的 第一个语句 形如 this(…) ，这个构造器将调用同一个类的另一个构造器。 super 也有两种用法： 关键字 super 用来调用超类的方法。 作为子类构造器的第一条语句来调用父类构造器。 方法详解Java程序总是 按值调用，就是说，方法的参数传递方式只有一种：按值传递。就是将实际参数值的副本传入方法内。如果传入的是基本数据类型，那么传递的是数据的一个拷贝；如果传递的是一个引用类型，那么传递的是该引用所指向的对象地址。特别指出的是，方法不能修改传递给它的任何参数变量的内容。 总结一下 Java 中方法参数的使用： 一个方法不能修改一个基本类型数据的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 成员变量和局部变量成员变量无须显式初始化，但局部变量必须要显式初始化。 变量的初始化和内存中的运行机制当系统加载类或创建该类的实例时，系统自动为成员变量分配内存空间，并在分配内存空间后，自动为成员变量指定初始值。 局部变量保存在其所在方法的栈内存中，如果局部变量是一个基本类型的变量，则直接把这个变量的值保存在该变量对应的内存中；如果局部变量是一个引用类型的变量，则这个变量里存放的是实际引用的对象或数组的堆内存地址。局部变量随方法或代码块的运行结束而结束。 引用变量的强制类型转换在多态中，引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法，即使它实际所引用的对象确实包含该方法。如确实需要让这个引用变量调用它运行时类型的方法，则必须把它强制类型转换成运行时类型，强制类型转换需要借助于类型转换运算符。 类型转换运算符的用法是：(type)variable，这种用法可以将 variable 变量转换成一个 type 类型的变量。类型转换运算符除了可以将一个基本类型变量转换成另一个类型外，还可以将一个引用类型变量转换成其子类类型。要注意的是： 基本类型之间的转换只能在数值类型之间进行，包括整数型、字符型和浮点型。 引用类型之间的转换只能在具有继承关系的两个类型之间进行。如果试图把一个父类实例转换成子类类型，则这个对象必须实际上是子类实例才行（即编译时类型为父类类型，而运行时类型是子类类型，即多态）。 1234//obj 变量在编译时类型为 Object，运行时类型为 String，Object 与 String//存在继承关系，可以强制类型转换Object obj=&quot;Hello&quot;;String objStr=(String)obj; 考虑到进行强制类型转换时可能出现异常，因此进行类型转换之前应该先通过 instanceof 运算符来判断是否可以成功转换。 instanceof 运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一个类或接口，它用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是，则返回 true。 instanceof 运算符前面操作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继承关系。否则会引发编译错误。1234567&gt;//声明 hello 时使用 Object 类，则 hello 的编译类型是 Object&gt;//Object 是所有类的父类，但 hello 变量的实际类型是 String&gt;Object hello=&quot;Hello&quot;;&gt;//String 与 Object 类存在继承关系，所以进行 instanceof 运算返回 true&gt;System.out.pritnln((hello instanceof Object));//返回 true&gt;System.out.pritnln((hello instanceof String));//返回 true&gt; 继承和组合继承是实现类复用的重要手段，但继承带来了一个最大的坏处：破坏封装。相比之下，组合也是实现类复用的重要方式，而采用组合方式来实现类复用能提供更好的封装性。 继承之所以破坏了封装性是因为修饰符的不同封装：通过公有化方法访问私有化属性，使得数据不容易被任意窜改，常用private修饰属性。继承：通过子类继承父类从而获得父类的属性和方法，正常情况下，用protected修饰属性，专门用于给子类继承的，权限一般在本包下和子类里。继承破坏了封装：是因为属性的访问修饰符被修改，使得属性在本包和子类里可以任意修改属性的数据，数据的安全性从而得不到保障。 为了包装父类有良好的封装性，不会被子类随意改变，设计父类通常应该遵循如下规则： 尽量隐藏父类的内部数据。把父类的所有成员变量都用 private 修饰，不要让子类直接访问父类的成员变量。 不要让子类可以随意访问、修改父类的方法。父类中那些仅为辅助其他的工具方法，应该使用 private 修饰，让子类无法访问；如果父类中的方法需要被外部类调用，但又不希望子类重写该方法，可以用 final 修饰；如果希望父类的某个方法被子类重写，但不希望被其他类访问，则使用 protected 修饰。 尽量不要在父类构造器中调用将要被子类重写的方法。 初始化块当创建对象时，系统总是先调用该类里定义的初始化块，如果一个类里定义了2个初始化块，则前面定义的先执行。对初始化块完成隐式执行后，再进行构造器的执行。 静态初始化块静态初始化块用 static 修饰，系统将在类初始化阶段执行静态初始化块，而不是再创建对象时才执行。与普通初始化块类似的是，系统在类初始化阶段执行静态初始化块时，不仅会执行本类的静态初始化块，而且还会一直上溯到其父类的静态初始化块。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-List 集合]]></title>
    <url>%2F2018%2F03%2F25%2FJava%2F8-List%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[List集合List 集合是有序集合，元素可以重复，可以根据索引操作元素： List 集合判断两个对象相等的标准是只要通过 equals() 方法比较返回 true 即可。当试图删除一个对象时，List 将会调用该对象的 equals() 方法依次与集合元素进行比较，如果该 equals() 方法以某个集合元素作为参数时返回 true，List 将会删除该元素。 Java8 为 List 集合增加了 sort() 和 replaceAll() 两个常用的默认方法： sort() 方法需要一个 Comparator 对象来控制元素排列。 replaceAll() 方法需要一个 UnaryOperator 来替换所有集合元素。 List 还提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象，这是一个迭代器，该对象有如下方法： boolean hasPrevious()：返回该迭代器关联的集合是否还有上一个元素。 Object previous()：返回该迭代器的上一个元素。 void add(Object o)：在指定位置插入一个元素。 ArrayList 和 Vector 实现类ArrayList 和 Vector 作为 List 的两个实现类，完全支持 List 接口的全部功能。这两个实现类都是基于数组实现，所以 ArrayList 和 Vector 类封装了一个动态的、允许再分配的 Object[] 数组。使用 initialCapacity 参数来设置该数组的长度，默认长度是 10，当发生自动扩容时会自动增大到原来的 1.5 倍。 有如下方法可以重新分配 Object[] 数组： void ensureCapacity(int minCapacity)：将 ArrayList 或 Vector 集合的 Object[] 数组长度增加大于或等于 minCapacity 值。 void trimToSize()：调整 ArrayList 或 Vector 集合的 Obje[] 数组长度为当前元素的个数，可以减少占用的存储空间。 ArrayList 和 Vector 的显著区别是：ArrayList 是非线程安全的。但是不推荐使用 Vector。后面可以利用 Collections 工具类把 ArrayList 包装成线程安全的。 固定长度的 List在数组中有一个操作数组的工具类：Arrays，该工具类提供了 asList(Object… a) 方法，可以把一个数组或指定个数的对象转换成一个 List 集合，这个 List 既不是 ArrayList 实现类，也不是 Vector 实现类，而是 Arrays 的内部类 ArrayList 的实例。该 Arrays.ArrayList 是一个固定长度的 List 集合，程序只能遍历访问该集合里的元素，不可增减、删除该集合里的元素：123456List fixedList = Arrays.asList(&quot;疯狂 Java 讲义&quot;,&quot;轻量级 Java EE 企业应用实战&quot;);//获取 fixedList 的实现类，将输出 Array$ArrayListSystem.out.pritntln(fixedList.getClass());//使用方法引用遍历集合元素fixedList.forEach(System.out::println);//试图增加、删除元素都会引发 UnsupportedOperationexception]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-Map 集合]]></title>
    <url>%2F2018%2F03%2F25%2FJava%2F8-Map%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Map 集合Map 用于保存具有映射关系–”key-value” 的数据。 HashMap、Hashtable 判断两个 key 相等的标准是：两个 key 的 hashCode 值相等，并且两个 key 通过 equals() 方法比较返回 true。 HashMap、Hashtable 判断两个 value 相等的标准是：两个 value 通过 equals() 方法比较返回 true 即可。 Map 的 key 不允许重复，同一个 Map 对象的任何两个 key 通过 equals 方法比较总是返回 false。key 和 value 之间存在单向一对一关系，通过指定的 key ，总能找到唯一、确定的 value。把 Map 里所有的 key 通过 keySet() 方法返回 Map 里所有 key 组成的 Set 集合。 Map 非常类似于 List，其中 values 元素可以重复，只不过 Map 中的索引是使用 key 对象。如果需要从 Map 中取出元素 value，则需要提供该元素的 key 索引。 在 Java 源码中，是先实现了 Map，然后通过包装一个所有 values 都为 null 的 Map 就实现了 Set。 Map 中定义了如下常用方法： Map 接口提供了大量的实现类，如 HashMap 和 Hashtable、HashMap 的子类 LinkedHashMap，还有 SortedMap 子接口以及该接口的实现类 TreeMap，以及 WeakHashMap 、IdentityHashMap。 Map 中包含了一个内部类 Entry，该内部类封装了一个 key-value 对，Entry 包含如下方法： Object getKey()：返回该 Entry 里包含的 key 值。 Object getValue()：返回该 Entry 里包含的 value 值。 Object setValue(V value)：设置该 Entry 里包含的 value 值，并返回新设置的 value 值。 Map 集合典型的用法就是成对地添加、删除 key-value 对，接下来即可判断该 Map 中是否包含指定 key，是否包含指定 value，也可以通过 Map 提供的 keySet() 方法获取所有 key 组成的集合，进而遍历 Map 中所有的 key-value 对。HashMap 重写了 toString() 方法，返回如下格式的字符串：{ key1=value1,key2=value2…. } Java8 为 Map 新增的方法 Java8 改进的 HashMap 和 Hashtable 实现类HashMap 和 Hashtable 之间的关系类似于 ArrayList 和 Vectory。但 Hashtable 过于古老，基本不用。它们的区别主要在 Hashtable 是一个线程安全的 Map 实现；而且 Hashtable 不允许使用 null 作为 key 和 value，但 HashMap 可以使用 null 作为 key 或 value(只允许存在一个 null)。 总结：在 hashMap 中放入（put）元素，有以下重要步骤： 计算 key 的 hash 值，算出元素在底层数组中的下标位置。 通过下标位置定位到底层数组里的元素（也有可能是链表也有可能是树）。 取到元素，判断放入元素的 key 是否 == 或 equals 当前位置的 key，成立则替换 value 值，返回旧值。4 如果是树，循环树中的节点，判断放入元素的 key 是否 == 或 equals 节点的 key，成立则替换树里的 value，并返回旧值，不成立就添加到树里。 否则就顺着元素的链表结构循环节点，判断放入元素的 key 是否 == 或 equals 节点的 key，成立则替换链表里 value，并返回旧值，找不到就添加到链表的最后。 精简一下，判断放入HashMap中的元素要不要替换当前节点的元素，key满足以下两个条件即可替换： hash 值相等。 == 或 equals 的结果为 true。 由于 hash 算法依赖于对象本身的 hashCode 方法，所以对于 HashMap 里的元素来说，hashCode 方法与 equals 方法非常的重要，重写对象的 equals 方法一定要重写 hashCode 方法，不重写的话，放到 HashMap 中可能会得不到你想要的结果！本示例中放入的 key 是 String 类型的，String 这个类已经重写了 hashCode 方法。 LinkedHashMap 实现类LinkedHashMap 使用双向链表来维护 key-value 的次序，该链表负责维护 Map 的迭代顺序，顺序与 key-value 对的插入顺序保持一致。迭代输出元素时，将会按添加 key-value 对的顺序输出。 使用 Properties 读写属性文件Properties 类是 Hashtable 类的子类，该对象在处理属性文件时特别方便。它可以把 Map 对象和属性文件关联起来，从而可以把 Map 对象中的 key-value 对写入属性文件中，也可以把属性文件中的 “属性名=属性值” 加载到 Map 对象中。 Properties 相当于一个 key、value 都是 String 类型的 Map。 Properties 类提供了如下三个方法来修改 Properties 里的 key、value值： String getProperty(String key)：获取 Properties 中指定属性名对应的属性值，类似于 Map 的 get(Object key)方法。 String getProperty(String key,String defaultValue)：该方法与前一个方法基本相似，如果不存在指定 key 时，可以指定默认值。 Object setProperty(String key,String value)：设置属性值。 void load(InputStream inStream)：从属性文件中加载 key-value 对，把加载到的 key-value 对追加到 Properties 里。 void store(OutputStream out,String comments)：将 Properties 中的 key-value 对输出到指定的属性文件中 SortedMap 接口和 TreeMap 实现类Map 接口也派生出一个 SortedMap 子接口，SortedMap 接口也有一个 TreeMap 实现类。 TreeMap 是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap 存储 key-value 对(节点) 时，需要根据 key 对节点进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态 TreeMap 也有两种排列方式： 自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，且所有的 key 应该是同一个类的对象。 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key进行排序。 TreeMap 中判断两个 key 相等的标准是：两个 key 通过 compareTo() 返回 0。使用自定义类作为 TreeMap 的 key，则重写该类的 equals() 方法和 compareTo() 方法时应该保持一致的返回结果：两个 key 通过 equals() 方法返回 true 时，它们通过 compareTo() 方法比较应该也返回 0. WeakHashMap 实现类HashMap 的 key 保留了对实际对象的 强引用，意味着只要该 HashMap 对象不被销毁，该 HashMap 的所有 key 所引用的对象就不会被垃圾回收，HashMap 也不会自动删除这些 key 所对应的 key-value 对； WeakHashMap 的 key 保留了对实际对象的弱引用，意味着如果 WeakHashMap 对象的 key 所引用的对象没有被其他强引用变量所引用，则这些 key 所引用的对象可能被垃圾回收，WeakHashMap 也可能自动删除这些 key 所对应的 key-value。 IdentityHashMap 实现类IdentityHashMap 在处理两个 key 相等时比较独特：当且仅当两个 key 严格相等 （key1 == key2）时，IdentityHashMap 才认为两个 key 相等；对于普通的 HashMap 而言，只要 key1 和 key2 通过 equals() 方法比较返回 true，且它们的 hashCode 值相等即可。 EnumMap 实现类EnumMap 是一个与枚举类一起使用的 Map 实现，EnumMap 中的所有 key 都必须是单个枚举类的枚举值。创建 EnumMap 时必须显式或隐式指定它对应的枚举类。 EnumMap 具有如下特征： EnumMap 在内部以数组形式保存，所以这种实现形式非常紧凑、高效。 EnumMap 根据 key 的自然顺序（即枚举值在枚举类中的定义顺序）来维护 key-value 对的顺序。当程序通过 keySet()、entrySet()、value() 等方法遍历 EnumMap 时可以看到这种顺序。 EnumMap 不允许使用 null 作为 key，但允许使用 null 作为 value。 创建 EnumMap 时必须指定一个枚举类，从而将该 EnumMap 和 指定枚举类关联起来。123456enum Season&#123; SPRING、SUMMER、FALL、WINTER；&#125;EnumMap enumMap=new EnumMap(Season.class); HashSet 和 HashMap 性能分析]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-Queue 队列]]></title>
    <url>%2F2018%2F03%2F25%2FJava%2F8-Queue%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Queue 集合Queue 用于模拟 队列(先进先出) 这种数据结构。新元素 插入(offer) 到队列的尾部，访问元素(poll) 会返回队列头部的元素，队列不允许随机访问队列中的元素。 Queue 接口中定义了如下几个方法： void add(Object e)：将指定元素加入此队列的尾部。 Object element()：获取队列头部的元素，但是不删除该元素。 boolean offer(Object e)：将指定元素加入此队列的尾部。当使用有容量限制的队列时，此方法通常比 add(Object e) 方法更好。 Object peek()：获取队列头部的元素，但是不删除该元素。如果队列为空，则返回 null。 Object poll()：获取队列头部的元素，并删除元素。如果队列为空，则返回null。 Object remove()：获取队列头部的元素，并删除元素。 Queue 接口有一个 PriorityQueue 实现类。 Queue 还有一个 Deque 接口，代表一个 双向队列 ，双向队列可以同时从两端来添加、删除元素，因此 Deque 的实现类既可以当成队列使用，也可以当成栈使用。Deque 有 ArrayDeque 和 LinkedList 两个实现类。 PriorityQueue 实现类PriorityQueue 是一个比较标准的队列实现类，保存队列元素的顺序并不是按加入队列的顺序，而是按队列元素的从小到大进行重新排序。因此当调用 peek() 或 poll() 方法取出队列中元素时，并不是取出最先进入队列的元素，而是取出队列中最小的元素。 从以上定义看，PriorityQueue 已经违反了队列的最基本规则：先进先出。 PriorityQueue 不允许插入 null 元素，它还需要对队列元素进行排序，且有两种排序方式： 自然排序：采用自然排序的 PriorityQueue 集合中的元素必须实现了 Comparable 接口，而且应该是同一个类的多个实例，否则会引发 ClassCastException 异常。 定制排序：创建 PriorityQueue 队列时，传入一个 Comparator 对象，该对象负责对队列中的所有元素进行排序。 Deque 接口与 ArrayDeque 实现类Deque 接口是 Queue 接口的子接口，它代表一个双端队列，允许从队列两端操作队列的元素：可以看出，Deque 不仅可以当成双端队列使用，还可以被当作栈来使用，因为该类里还包括了 pop(出栈)、push(入栈) 两个方法。 ArrayDequeDeque 接口提供了一个典型的实现类：ArrayDeque，它是一个基于数组实现的双端队列。创建 Deque 时可指定一个 numElements 参数，用于指定 Object[] 数组的长度。默认底层数组的长度为16。1234567ArrayDeque stack = new ArrayDeque();//依次将三个元素 push 入 &quot;栈&quot;，区别于 add/offer 入 &quot;队列&quot;stack.push(&quot;疯狂 Java 讲义&quot;);stack.push(&quot;轻量级 Java EE 企业应用实战&quot;);stack.push(&quot;疯狂 Android 讲义&quot;);//输出：[ 疯狂 Android 讲义，轻量级 Java EE 企业应用实战，疯狂 Java 讲义]System.out.println(stack); 当程序中需要使用 “栈” 时，推荐使用 ArrayDeque。 LinkedList 实现类LinkedList 类是 List 接口的实现类，同时还实现了 Deque 接口，因此可以作为 List集合使用，根据索引来随机访问集合中元素；同时还可以作为 栈、队列 使用。 LinkedList 与 ArrayList、ArrayDeque 的实现机制完全不同，ArrayList、ArrayDeque 内部以数组的形式来保存集合中的元素，因此随机访问集合元素时有较好的性能；而 LinkedList 内部以链表的形式来保存集合元素，因此随机访问集合元素性能较差，但在插入、删除元素时性能出色。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-Set 集合]]></title>
    <url>%2F2018%2F03%2F25%2FJava%2F8-Set%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Set集合Set 集合不允许包含相同的元素，主要介绍 HashSet、TreeSet 和 EnumSet。 HashSet类 不保证元素的排列顺序。 HashSet不是同步的，如果多个线程同时访问一个 HashSet，假设有两个或以上的线程同时修改了 HashSet 集合，则必须通过代码来保证同步。 HashSet 集合元素可以是 null。 当向 HashSet 集合存入一个元素时，HashSet 会调用该对象的 hashCode() 方法得到该对象的 hashCode 值，然后根据该 hashCode 值决定该对象在 HashSet 中的存储位置。如果有两个元素通过 equals() 方法比较返回 true，但它们的 hashCode() 方法返回值不相等，HashSet 将会把它们存储在不同位置，依然可以添加成功。 也就是说，HashSet 集合判断两个元素相等的标准是两个对象通过 equals() 方法比较得出相等，并且两个对象的 hashCode() 方法返回值也相等。 当需要把某个类的对象保存到 HashSet 集合中，重写这个类的 equals() 和 hashCode() 方法时，应该尽量保证两个对象通过 equals() 方法比较返回 true 时，它们的 hashCode() 也会相等。 HashSet 访问元素集合是根据元素的 HashCode 值来快速定位的。 当程序把可变对象添加到 HashSet 中之后，尽量不要去修改该集合元素中参与计算 hashCode()、equals() 的实例变量，否则将会导致 HashSet 无法正确操作这些集合元素。 HashSet 中每个能存储元素的 “槽位(slot)” 通常称为 “桶(bucket)”，如果有多个元素的 hashCode 值相同，但它们通过 equals() 方法比较返回 true，就需要在一个 “桶” 里放多个元素，通常是用链表实现。 LinkedHashSet 类HashSet 类还有一个子类 LinkedHashSet，它使用链表来维护元素的次序，这样使得元素看起来是以插入的顺序保存的。当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 将会按元素的添加顺序来访问集合里的元素。 LinkedHashSet 需要维护元素的插入顺序，因此性能略低于 HashSet 的性能，但是在迭代访问 Set 里的全部元素时性能很好，因为它以链表来维护内部顺序。 TreeSet 类TreeSet 是 SortedSet 接口的实现类，它可以确保集合元素处于排序状态。也就是说，TreeSet 并不是根据元素的插入顺序进行排序的，而是根据元素实际值的大小来进行排序的。 TreeSet 采用红黑树的数据结构来存储集合元素。TreeSet 支持两种排序方法：自然排序 和 定制排序： 自然排序 TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按 升序 排列。 Java 提供了一个 Comparable 接口，里面定义了一个 compareTo(Object obj) 方法，该方法返回一个整数值。当一个对象调用该方法与另一个对象进行比较时，例如 obj1.compareTo(obj2)，若相等则返回 0，若 obj1 大于 obj2，则返回一个正整数，若 obj1 小于 obj2，则返回一个负整数。 如果把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口，否则会抛出异常。并且，TreeSet 只能添加同一种类型的对象。 当把一个对象加入 TreeSet 集合中时，TreeSet 调用该对象的 compareTo(Object obj) 方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过 compareTo(Object obj) 方法比较相等，新对象将无法添加到 TreeSet 集合中。 对于 TreeSet 集合来说，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较是否返回 0。 定制排序 如果要实现定制排序，例如以降序排列，则可以通过 Comparator 接口。该接口包含一个 int compare(T o1,T o2) 方法，该方法用于比较 o1 和 o2 的大小。 当需要实现定制排序时，要在创建 TreeSet 集合对象时，提供一个 Comparator 对象与该 TreeSet 集合关联，由该 Comparator 对象负责集合元素的排列逻辑。由于 Comparator 是一个函数式接口，所以可以使用 Lambda表达式代替 Comparator 对象。123456789101112131415161718192021222324class M&#123; int age; public M(int age) &#123; this.age = age; &#125; public String toString() &#123; return &quot;M[age:&quot; + age + &quot;]&quot; &#125;&#125;public class TreeSetTest&#123; public static void main(String[] args) &#123; TreeSet ts=new TreeSet( (o1,o2)-&gt;&#123; M m1=(M)o1; M m2=(M)o2; //根据 M 对象的 age 属性来决定大小，age 越大，M 对象反而越小 return m1.age &gt; m2.age ? -1:m1.age&lt;m2.age ? 1:0;&#125;; ts.add(new M(5)); ts.add(new M(-3)); ts.add(new M(9)); System.out.println(ts); &#125;&#125; 与 HashSet 集合相比，TreeSet 还提供了几个额外的方法： Comparator comparator()：如果 TreeSet 采用了定制排序，则该方法返回定制排序所使用的 Comparator；如果 TreeSet 采用了自然排序，则返回 null。 Object first()：返回集合中的第一个元素。 Object last()：返回集合中的最后一个元素。 Object lower(Object e)：返回集合中小于指定元素的最大元素，参考元素不需要是 TreeSet 集合里的元素。 Object higher(Object e)：返回集合中大于指定元素的最小元素，参考元素不需要是 TreeSet 集合里的元素。 SortedSet subSet(Object fromElement,Object toElement)：返回此 Set 的子集合，范围从 fromElement（包含）到 toElement（不包含）。 SortedSet headSet(Object toElement)：返回此 Set 的子集合，由小于 toElement 的元素组成。 SortedSet tailSet(Object fromElement)：返回此 Set 的子集合，由大于或等于 fromElement 的元素组成。 EnumSet 类EnumSet 类是一个专为枚举类设计的集合类，EnumSet 中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建 EnumSet 时显式或隐式指定。EnumSet 以枚举值在 Enum 类的定义顺序来决定集合元素的顺序。 EnumSet 在内部以 位向量 的形式存储，占用内存很小，运行效率高，尤其是进行批量操作时。EnumSet 集合不允许加入 null 元素，否则将抛出 NullPointerException。 EnumSet 类没有暴露任何构造器来创建该类的实例，通过它提供的静态方法来创建 EumSet 对象： EnumSet allOf(Class elemetnType)：创建一个包含指定枚举类里所有枚举值的 EnumSet 集合。 EnumSet complementOf(EnumSet s)：创建一个其元素类型与指定 EnumSet 里元素类型相同的 EnumSet 集合，新 EnumSet 集合包含原 EnumSet 集合所不包含的、此枚举类剩下的枚举值。 EnumSet copyOf(Collection c)：使用一个普通集合来创建 EnumSet 集合。 EnumSet copyOf(EnumSet s)：创建一个与指定 EnumSet 具有相同元素类型、相同集合元素的 EnumSet 集合。 EnumSet noneOf(Class elementType)：创建一个元素类型为指定枚举类型的空 EnumSet。 EnumSet of(E first,E…rest)：创建一个包含一个或多个枚举值的 EnumSet 集合，传入的多个枚举值必须属于同一个枚举类。 EnumSet range(E from,E to)：创建一个包含从 from 枚举值到 to 枚举值范围内所有枚举值的 EnumSet 集合。 各 Set 实现类的性能分析HashSet 的性能总是比 TreeSet 好(特别是最常用的添加、查询元素等操作)，因为 TreeSet 需要额外的红黑树算法来维护集合元素的次序。 HashSet 还有一个子类：LinkedHashSet，对于普通的插入、删除操作，LinkedHashSet 比 HashSet 要略微慢一点，但是遍历 LinkedHashSet 会更快。 EnumSet 是所有 Set 实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素。 Set 的三个实现类，HashSet、TreeSet 和 EnumSet 都是线程不安全的。可以通过 Collections 工具类的 **synchronizedSortedSet() 方法来包装该 Set 集合，并最好在创建 Set 集合时进行。1SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集]]></title>
    <url>%2F2018%2F03%2F17%2FJava%2F%E5%AD%97%E7%AC%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[计算机里的所有文件在底层都是二进制文件，即全部都是字节码，图片、视频、音频只是二进制文件的一种表现形式。对于文本文件而言，之所以可以看到一个个的字符，这完全是因为系统将底层的二进制序列转换成字符的缘故。在这个过程涉及到两个概念：编码（Encode）和 解码（Decode）。Java默认使用 Unicode 字符集，提供了 Charset 类来处理字节序列和字符序列（字符串）之间的转换关系。该类包含了用于创建解码器和编码器的方法，还提供了静态方法 availableCharset() 来获取 Charset 所支持字符集的方法。Charset 类是不可变类。 所谓字符集，就是为每个字符编个号码而已。任何人都可以制定自己独有的字符集，只要为每个字符编个号码即可。可以使用 System 类的 getProperties() 方法来访问本地系统的文件编码格式。 通过 Charset 的 forName() 方法来创建对应的 Charset 对象：1Charset charset=Charset.forName("UTF-8"); 获取了 Charset 对象之后，就可以通过该对象的 newDecoder()、newEncoder() 这个两个方法分别返回 CharsetDecoder() 和 CharsetEncoder 对象。调用 CharsetDecoder 的 decode() 方法就可以将 ByteBuffer(字节序列) 解码转换成 CharBuffer(字符序列)，调用 CharsetEncoder 的 encode() 方法就可以将 CharBuffer 或 String(字符序列) 编码转换成 ByteBuffer(字节序列)。123456789101112131415161718192021//创建简体中文对应的 CharsetCharset charset_cn=Charset.forName(&quot;GBK&quot;);//获取 charset_cn 对象对应的编码器和解码器CharsetEncoder cnEncoder=charset_cn.newEncoder();CharsetDecoder cnDecoder=charset_cn.newDecoder();//创建一个 CharBuffer 对象CharBuffer cbuffer=CharBuffer.allocate(32);cbuffer.put(&apos;孙&apos;);cbuffer.put(&apos;悟&apos;);cbuffer.put(&apos;空&apos;);cbuffer.flip();//将 CharBuffer 中的字符序列转换成字节序列ByteBuffer bbuffer=cnEncoder.encode(cbuffer);//循环访问 ByteBuffer 中的每个字节for(int i=0;i&lt;bbuffer.capacity();i++&#123; System.out.println(bbuffer.get(i)+&quot; &quot;);&#125;//将 ByteBuffer 中的数据解码成字符序列System.out.pritnln(cnDecoder.decode(bbuffer);&#125; 实际上，如果仅仅需要进行简单的编码、解码操作，其实无须创建 CharsetEncoder 和 CharsetDecoder，可以直接调用 Charset 的 encode() 和 decode() 方法： CharBuffer decode(ByteBuffer bb)：将ByteBuffer中的字节序列转换成字符序列的便捷方法。 ByteBuffer encode(CharBuffer cb)：将CharBuffer中的字符序列转换成字节序列的便捷方法。 ByteBuffer encode(String str)：将String中的字符序列转换成字节序列的便捷方法。 在String类里也提供了一个 getBytes(String charset) 方法，该方法返回 byte[]，该方法也是使用指定的字符集将字符串转换成字节序列]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15-NIO体系]]></title>
    <url>%2F2018%2F03%2F15%2FJava%2F15-NIO%2F</url>
    <content type="text"><![CDATA[NIO 体系NIO 跟传统的 IO 一样都用于输入/输出，但 NIO 采用了内存映射文件的方式来处理输入/输出。NIO 将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件，相比于传统 IO 要快得多。 Java 中与 NIO 有关的包： java.nio：主要包含各种与 Buffer 相关的类。 java.nio.channels：主要包含与 Channel 和 Selector 相关的类。 java.nio.charset：主要包含与字符集相关的类。 java.nio.channels.spi：主要包含与 Channel 相关的服务提供者编程接口。 java.nio.charset.spi：包含于字符集相关的服务提供者编程接口。 Channel(通道) 和 Buffer(缓冲)Channel 是对传统的输入/输出系统的模拟，在 NIO 中所有数据都需要通过 Channel 传输。Channel 提供了一个 map() 方法，可以直接将 “一块数据” 映射到内存中。 Buffer(缓冲) 本质是一个数组，是一个容器。发送到 Channel 中的所有对象都必须首先放到 Buffer 中，而从 Channel 中读取的数据也必须先放到 Buffer 中。 除了 Channel 和 Buffer 之外，新 IO 还提供了用于将 Unicode 字符映射成字节序列以及逆映射操作的 Charset 类，也提供了用于支持非阻塞式 输入/输出 的 Selector 类。 BufferBuffer 是一个抽象类，对应于其他基本数据类型都有相应的 Buffer 类：CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。通过 static XxxBuffer allocate(int capacity) 静态方法来获取一个容量为 capacity 的 XxxBuffer 对象。 ByteBuffer 类还有一个子类：MappedByteBuffer，它用于表示 Channel 将文件的部分或全部内容映射到内存中后得到的结果，由 Channel 的 map() 方法返回对应文件的 MappedByteBuffer。 Buffer 中有三个重要的概念：容量(capacity)、界限(limit) 和 位置(position)： 容量(capacity)：缓冲区的 容量(capacity) 表示该 Buffer 的最大数据容量。缓冲区的容量不可能为负值，创建后不能改变。 界限(limit)：第一个不应该被读出或写入的缓冲区位置索引。也就是说，位于 limit 后的数据既不可被读，也不可被写。 位置(position)：用于指明下一个可以被读出或者写入的缓冲区位置索引。当使用 Buffer 从 Channel 中读取数据时，position 的值恰好等于已经读到了多少数据。当新建一个 Buffer 对象时，其中 position 为 0；如果从 Channel 中读取了 2 个数据到该 Buufer 中，则 position 为 2，指向 Buffer 中第3个(第1个位置索引为0)位置。 除此之外，Buffer 还支持一个可选的标记 mark，Buffer 允许直接将 position 的定位到 mark 处。这些值存在以下关系：10 &lt;= mark &lt;= position &lt;= limit &lt;= capacity Buffer 的主要作用就是装入数据，然后输出数据。开始的 Buffer 的 position 为 0，limit 为 capacity，mark=-1。程序可以通过 put() 方法向 Buffer 中放入一些数据(或者从 Channel 中获取一些数据)，每放入一些数据，Buffer 的 position 相应地向后移动一些位置。 当 Buffer 装入数据后，调用 Buffer 的 flip() 方法，该方法将 limit 设置为 position 所在位置，并将 position 设为 0，这就使得 Buffer 的读写指针又移动到开始位置。也就是说，Buffer 调用 flip() 方法之后，Buffer 为输出数据做好准备；当 Buffer 输出数据结束后，Buffer 调用 clear() 方法，clear() 方法并非清空 Buffer 的数据，它仅仅将 position 置为 0，将 limit 置为 capacity，这样再次向 Buffer 中装入数据做好准备。 Buffer 还有如下一些常用方法： int capacity()：返回 Buffer 的 capacity 大小。 boolean hasRemaing()：判断当前 position 和 limit 之间是否还有元素可供处理。 int limit()：返回 Buffer 的 limit 的位置。 Buffer limit(int newLt)：重新设置 limit 的值，并返回一个具有新的 limit 的缓冲区对象。 Buffer mark()：设置 Buffer 的 mark 位置，它只能在 0 和 position 之间做 mark。 int position()：返回 Buffer 中的 position 值。 Buffer position(int newPs)：设置 Buffer 的 position，并返回 position 被修改后的 Buffer 对象。 int remaining()：返回当前 position 和 limit 之间的元素个数。 Buffer reset()：将 position 转到 mark 所在的位置。 Buffer rewind()：将 position 设置成 0，取消设置的 mark。 Buffer 的所有子类还提供了两个重要的方法：put() 和 get() 方法，用于向 Buffer 中放入数据和从 Buffer 中取出数据。当使用 put() 和 get() 方法放入、取出数据时，Buffer 既支持对单个数据的访问，也支持对批量数据的访问(以数组作为参数)。当使用 put() 和 get() 来访问 Buffer 中的数据时，分为相对和绝对两种： 相对：从 Buffer 的当前 position 处开始读取或写入数据，然后将 position 的值按处理元素的个数增加。 绝对：直接根据索引向 Buffer 中读取或写入数据，使用绝对方式访问 Buffer 里的数据时，并不会影响 position 的值。 ChannelChannel 类似于传统的流对象，但与传统的流对象有两个主要区别： Channel 可以直接将指定文件的部分或全部直接映射成 Buffer。 程序不能直接访问 Channel 中的数据，包括读取、写入都不行，Channel 只能与 Buffer 进行交互。 Java 为 Channel 接口按功能提供了以下常用实现类： Pipe.SinkChannel 和 Pipe.SourceChannel：用于支持线程之间通信管道。 FileChannel：用于对文件进行操作。 SelectableChannel ServerSocketChannel 和 SocketChannel：用于支持 TCP 网络通信。 DatagramChannel：用于支持 UDP 网络通信。 所有的 Channel 都不应该通过构造器来直接创建，而是通过传统的节点 InputStream、OutputStream 的 getChanne() 方法来返回对应的 Channel，不同的节点流获得的 Channel 不一样。例如，FileInputStream、FileOutputStream 的getChannel() 返回的是 FileChannel，而 PipeInputStream 和 PipeOutputStream 的 getChannel() 返回的是 Pipe.SinkChannel 和 Pipe.SourceChannel。 Channel 中最常用的三类方法是 map()、read() 和 write()。其中 map() 方法用于将 Channel 对应的部分或全部数据映射成 ByteBuffer；而 read() 或 write() 方法都有一系列重载形式，这些方法用于从 Buffer 中读取数据或向 Buffer 中写入数据。 map() 方法的签名为：MappedByteBuffer map(FileChannel.MapMode mode,long position,long size)，第一个参数执行映射时的模式，有 只读、读写等 模式；而第二个、第三个参数用于控制将 Channel 的哪些数据映射成 ByteBuffer。 直接将 FileChannel 的全部数据映射成 ByteBuffer：123456789101112131415161718192021222324File file=new File(&quot;D:\\FileChannel.java&quot;);try(//根据文件输入流创建ChannelFileChannel inputFileChannel=new FileInputStream(file).getChannel();//根据文件输出流创建ChannelFileChannel outputFileChannel=new FileOutputStream(&quot;D:\\a.txt&quot;).getChannel())&#123; //将 FileChannel 里的全部数据映射成 ByteBuffer MappedByteBuffer buffer=inputFileChannel.map(FileChannel.MapMode.READ_ONLY,0,f.length()); //使用 UTF-8 的字符集来创建解码器 Charset charset=Charset.forName(&quot;UTF-8&quot;); //直接将 buffer 里的数据全部输出到 OutputChannel outputFileChannel.write(buffer); //调用 buffer 的 clear() 方法，重置 limit、position的位置 buffer.clear(); //根据前面定义的 charset 创建解码器（CharsetDecoder)对象 CharsetDecoder decoder=charset.newDecoder(); //使用解码器将 ByteBuffer 转换成 CharBuffer CharBuffer charBuffer=decoder.decode(buffer); //CharBuffer 的 toString（）方法可以获取对应的字符串 System.out.println(charBuffer.toString());&#125;catch(IOException e)&#123;&#125;&#125; 不仅 InputStream、OutputStream 包含了 getChannel() 方法，在 RandomAccessFile 中也包含了一个 getChannel()方法，至于 RandomAccessFile 返回的 FileChannel() 是只读的还是读写的，取决于 RandomAccessFile 打开文件的模式。 以下代码实现了文件内容的追加复制：1234567891011121314File file=new File(&quot;D:\\randomFile.txt&quot;);try(//创建一个RandomAccessFile对象RandomAccessFile raf=new RandomAccessFile(file,&quot;rw&quot;);//获取RandomAccessFile对应的ChannelFileChannel randomChannel=raf.getChannel())&#123; //将Channel中的所有数据映射成ByteBuffer ByteBuffer buffer=randomChannel.map(READ_ONLY,0,file.length()); //把Channel的记录指针移到最后 randomChannel.position(file.length()); //将buffer中的所有数据输出 randomChannl.write(buffer); 如果习惯了传统IO的”用竹筒多次重复取水”的过程，或者担心 Channel 对应的文件过大，使用 map() 一次将所有的文件内容映射到内存中引起性能下降，也可以使用 Channel 和 Buffer 传统的 “用竹筒多次重复取水” 的方式：123456789101112131415161718192021222324try(//创建文件输入流FileInputStream fis=new FileInputStream(&quot;readFile.java&quot;);//创建FileChannelFileChannel fileChannel=fis.getChannel();)&#123; //定义一个ByteBuffer对象，用于重复取水 ByteBuffer buffer=ByteBuffer.allocate(1024); //将FileChannel中的数据放入ByteBuffer while(fileChannel.read(buffer) != -1) &#123; //锁定buffer的空白区，避免读取到null的区域 buffer.flip(); //根据指定编码字符集创建解码器 Charset charset=Charset.forName(&quot;UTF-8&quot;); CharsetDecoder decoder=charset.newDecoder(); //将ByteBuffer的内容转码 CharBuffer charBuffer=decoder.decode(buffer); System.out.print(charBuffer); //将ByteBuffer对象重新初始化，为下一次读取数据做准备 buffer.clear(); &#125;&#125;catch(IOException e); 文件锁如果多个运行的程序需要并发修改同一个文件时，程序之间需要某种机制来进行通信，使用 文件锁 可以有效地阻止多个进程并发修改同一个文件，所以现在的大部分操作系统都提供了 文件锁 功能。 文件锁控制文件的全部或部分字节的访问，但文件锁在不同的操作系统中差别较大，从 NIO 开始 java 提供了 FileLock 来支持文件锁功能，在 FileChannel 中提供的 lock()/tryLock() 方法可以获得文件锁 FileLock 对象，从而锁定文件。 lock() 和 tryLock() 方法存在区别：当 lock() 试图锁定某个文件时，如果无法得到文件锁，程序将一直阻塞；而 tryLock() 是尝试锁定文件，它将直接返回而不是阻塞，如果获得了文件锁，该方法则返回文件锁，否则返回 null。 如果 FileChannel 只想锁定文件的部分内容，而不是锁定全部内容，则可以使用如下的 lock() 或 tryLock() 方法： lock(long position,long size,boolean shared)：对文件从 position 开始，长度为 size 的内容加锁，该方法是阻塞式的。 tryLock(long position,long size,boolean shared)：非阻塞式的加锁方法。参数的作用与上面一样。 当参数 shared 为 true 时，表明锁时一个共享锁，它将允许多个进程来读取该文件，但阻止其他进程获得对该文件的排他锁。当 shared 为 false 时，表明该锁是一个排他锁，它将锁住对该文件的读写。程序可以通过调用 FileLock() 的 isShared() 来判断它是否获得共享锁。直接使用无参数的 lock() 或 tryLock() 获得的是排他锁。当处理完文件后通过 FileLock 的 release() 方法释放文件锁。 1234567891011try(//使用FileOutputStream获得FileChannelFileChannel channel=new FileOutputStream(&quot;a.txt&quot;).getChannel())&#123; //使用非阻塞式方法对指定文件加锁 FileLock lock=channel.tryLock(); //程序暂停 10s Thread.sleep(10000); //释放锁 lock.release();&#125; NIO2Java7 对原有的 NIO 进行了重大改进： 提供了全面的文件 IO 和文件系统访问支持。 基于异步 Channel 的 AIO。 第一个改进表现为 Java7 新增的 java.nio.file 包以及各个子包；第二个改进表现为 Java7 在 java.nio.channels 包下增加了多个以 Asynchronous 开头的 channel 接口和类。 Path、Paths 和 Files 核心 API传统的 IO 提供了一个 File 类来访问文件系统，但 File 缺陷较多，功能有限，现在尽量不用。 NIO2 为了取代 File 类，引入了 Path 接口，Path 接口代表一个平台无关的平台路径。除此之外，NIO2 还提供了 Files、Paths 两个工具类，其中 Files 类包含了大量静态的工具方法来操作文件；Paths 则包含了两个返回 Path 的静态工厂方法。 Path 通过 Paths 的 get(String first,String…more) 或 get(URI uri) 方法来获取 Path 对象。要注意，创建 Path 并不会创建物理文件或者目录。 Files 是一个操作文件的工具类，它提供了大量便捷的工具方法：1234567891011121314151617//复制文件Files.copy(Paths.get(&quot;FilesTest.java&quot;),Paths.get(&quot;a.txt&quot;));//判断 FilesTest.java 文件是否为隐藏文件Files.isHidden(Paths.get(&quot;FilesTest.java&quot;));//一次性读取 FilesTest.java 文件的所有行List&lt;String&gt; lines=Files.readAllLines(Paths.get(&quot;FilesTest.java&quot;),Charset.forName(&quot;gbk&quot;));//判断指定文件的大小Files.size(Paths.get(&quot;FilesTest.java&quot;));//使用 Java8 新增的 Stream API 列出当前目录下所有文件和子目录Files.list(Paths.get(&quot;.&quot;)).forEach(path-&gt;System.out.println(path));//使用 Java8 新增的 Stream API 读取文件内容Files.lines(Paths.get(&quot;FilesTest.java&quot;),Charset.forName(&quot;gbk&quot;)).forEach(line-&gt;System.out.println(lint));FileStore cStore=Files.getFileStore(Paths.get(&quot;C:&quot;));//判断C盘的总空间、可用空间System.out.println(&quot;C:总空间： &quot;+ cStore.getTotleSpace());System.out.println(&quot;C:可用空间：&quot;+ cStore.getUsableSpace()); 使用 FileVisitor 遍历文件和目录早期版本中，程序要遍历指定目录下的所有文件和子目录，只能使用递归进行遍历，但这种方式不仅复杂，而且灵活性不高。现在在 Files 工具类中提供了如下两个方法来遍历文件和子目录： walkFileTree(Path start,FileVisitor&lt;? super Path&gt; visitor：遍历 start 路径下的所有文件和子目录。 walkFileTree(Path start,Set option,int maxDepth,FileVisitor&lt;? super Path&gt; visitor)：与上个方法功能类似。该方法最多可以遍历 maxDepth 深度的文件。 上述两个方法中的 FileVisitor 参数代表一个文件访问器，walkFileTree() 方法会自动遍历 star 路径下的所有文件和子目录，遍历文件和子目录都会出发 FileVisitor 中相应的方法。 FileVisitor 中定义了如下方法： FileVisitResult postVisitDirectory(T dir,IOException exc)：访问子目录之后触发该方法。 FileVisitResult preVisitDirectory(T dir,BasicFileAttributes attrs)：访问子目录之前触发该方法。 FileVisitResult visitFile(T file,BasicFileAttributes attrs)：访问 file 文件时触发该方法。 FileVisitResult visitFileFailed(T file,IOException exc)：访问 file 文件失败时触发该方法。 上面4个方法都返回一个 FileVisitResult 对象，它是一个枚举类，代表了访问之后的后续行为： CONTINUE：代表”继续访问”的后续行为。 SKIP_SIBLINGS：代表”继续访问”的后续行为，但不访问该文件或目录的兄弟文件或目录。 SKIP_SUBTREE：代表”继续访问”的后续行为，但不访问该文件或目录的子目录。 TERMINATE：代表”中止访问”的后续行为。 可以通过继承 SimpleFileVisitor类（FileVisitor的实现类）来实现自己的”文件访问器”，根据需要、选择性地重写指定方法。 下面示范了如何使用 FileVisitor 来遍历文件和子目录： 12345678910111213141516171819202122232425262728293031323334353637383940//遍历 D:/ 下的所有文件和目录//并把遍历结果保存到 D:/file_walk_tree.txt 文件中Path path = Paths.get("D:/");FileVisitor&lt;Path&gt; fileVisitor = new SimpleFileVisitor&lt;Path&gt;()&#123; @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) &#123; System.out.println("准备访问目录： " + dir); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) &#123; System.out.println(" " + "文件-" + file); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) &#123; System.out.println("离开目录： " + dir); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult visitFileFailed(Path file, IOException exc) &#123; return FileVisitResult.SKIP_SIBLINGS; &#125;&#125;;Path des = Paths.get("D:/file_walk_tree.txt");//重定向标准输出 System.out 到目标文件 D:/file_walk_tree.txtPrintStream printStream = new PrintStream(new FileOutputStream(des.toString()));PrintStream originPrintStream = System.out;System.setOut(printStream);Files.walkFileTree(path, fileVisitor);System.setOut(originPrintStream);System.out.println("遍历完成"); 使用 WatchService 监控文件变化如果要监控文件的变化，Path 类提供了如下一个方法： register(WatchService watcher,WatchEvent.Kind&lt;?&gt;…events)：用 watcher 监听该 path 代表的目录下的文件变化。events 参数指定要监听哪些类型的事件。 在这个方法中，WhatchService 代表一个文件系统监听服务，它负责监听 path 代表的目录下的文件变化。一旦使用 register() 方法完成注册之后，接下来就可以调用 WhatchService 的如下三个方法来监听目录的文件变化事件： WatchKey poll()：获取下一个 WatchKey，如果没有 WatcheKey 发生就立即返回 null。 WatchKey poll(long timeout，TimeUnit unit)：尝试等待 timeout 时间去获取下一个 WatchKey。 WatchKey take()：获取下一个 WatchKey，如果没有 WatchKey 发生就一直等待。 （待补充） 访问文件属性从 Java7 开始，java.nio.file.attribute 包下提供了大量的工具类，可以非常简单地读取、修改文件属性。这些工具类主要分为如下两类： XxxAttributeView：代表某种文件属性的 “视图”。 XxxAttributes：代表某种文件属性的 “集合”，程序一般通过 XxxAttributeView 对象来获取 XxxAttributes。 (待补充)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15-传统IO]]></title>
    <url>%2F2018%2F03%2F15%2FJava%2F15-%E4%BC%A0%E7%BB%9FIO%2F</url>
    <content type="text"><![CDATA[传统 IO 流体系理解节点流和处理流直接以物理资源建立的流就是节点流，把节点流包装就是处理流。 InputStream 和 ReaderInputSteam 和 Reader 是所有输入流的抽象基类，它们的方法所有输入流都可以使用： InputStream int read()：从输入流中读取单个字节，返回所读取的字节数据。 int read(byte[] b)：从输入流中最多读取 b.length 个字节的数据，并将其存储在字节数组 b 中，返回实际读取的字节数。 int read(byte[] b,int off,int len)：从输入流中最多读取 len 个字节的数据，并将其存储在数组 b 中，当放入数组 b 中时从数组的 off 位置开始放入，返回实际读取的字节数。 Reader int read()：从输入流中读取单个字符，返回所读取的字符数据。 int read(char[] cbuf)：从输入流中最多读取 cbuf.length 个字符的数据，并将其存储在字符数组 cbuf 中，返回实际读取的字符数。 int read(char[] cbuf,int off,int len)：从输入流中最多读取 len 个字符的数据，并将其存储在数组 cbuf 中，当放入数组 cbuf 中时从数组的 off 位置开始放入，返回实际读取的字符数。 除此之外，InputSteam 和 Reader 还支持以下方法来移动记录指针： void mark(int readAheadLimit)：在记录指针当前位置进行一个标记 mark。 boolean markSupported()：判断此输入流是否支持 mark() 操作 void reset()：将此流的记录指针重新定位到上一次标记 mark 的位置 long skip(logn n)：记录指针向前移动 n 个字节/字符 OutputSteam 和 WriterOutputStream 和 Writer 都提供如下方法： void write(int c)：将指定的字节/字符输出到输出流中，其中 c 既可以代表字节，也可以代表字符。 void writer(byte[]/char[] buf)：将字节数组/字符数组中的数据输出到指定输出流中。 void write(byte[]/char[] buf,int off,int len)：将字节数组/字符数组中从 off 位置开始，长度为 len 的字节/字符输出到输出流中。 Writer还包含以下方法： void writer(String str)：将 str 字符串里包含的字符输出到指定输出流中。 void write(String str,int off,int len)：将 str 字符串里从 off 位置开始，长度为 len 的字符输出到指定输出流中。 处理流的用法上述4个基类用起来很繁琐，此时就有了处理流。使用处理流的思路是，使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的 I/O 设备、文件交互。 实际识别处理流非常简单，只要流的构造器参数不是一个物理节点，而是已经存在的流，那么这种流就一定是处理流；而所有节点流都是直接以物理 IO 节点作为构造参数的。 输入/输出体系 4 个访问管道的流：PipeInputStream、PipeOutputStream、PipedReader、PipedWriter，用来实现进程之间通信功能。 4 个缓冲流：增加缓冲流之后需要使用 flush() 才可以将缓冲区的内容写入实际的物理节点。 对象流，主要用于实现对象的序列化。 转换流输入/输出 体系中还提供了两个转换流，用于实现将字节流转换成字符流。分别是 InputStreamReader 和 OutputStreamWriter 。普通的 Reader 读取输入内容时不太方便，此时可以将普通的 Reader 再次包装成 BufferedReader ，利用 BufferedReader 的 readLine() 方法可以一次读取一行文本内容。 BufferReader 有一个 readLine() 方法可以一次读取一行内容，方便读取文本内容。 推回输入流在输入/输出流体系中，有两个特殊的流与众不同，就是 PushbackInputStream 和 PushbackReader，它们都提供了如下方法： void unread(byte[]/char[] buf)：将一个字节/字符数组内容推回到 推回缓冲区，从而允许重复读取刚刚读取的内容 void unread(byte[]/char[] b,int off,int len)：将一个字节/字符数组里从 off 开始，长度为 len 字节/字符的内容推回到 推回缓冲区，从而允许重复读取刚刚读取的内容 void unread(int b)：将一个字节/字符推回到 推缓冲区，从而允许重复读取刚刚读取的内容 重定向标准输入/输出Java 的标准输入/输出分别通过 System.in 和 System.out 来实现，在默认情况下代表键盘和显示器。在 System 类里提供了如下三个重定向标准输入/输出的方法： static void setErr(PrintStream err)：重定向 “标准” 错误输出流 static void setIn(InputStream in)：重定向 “标准” 输入流 static void setOut(PrintStream out)：重定向 “标准” 输出流 RandomAccessFileRandomAccessFile 既可以读取文件内容，也可以向文件输出数据，与普通的输入流/输出流不同，RandomAccessFile 支持”随机访问”的方式，程序可以直接跳转到文件的任意地方来读写数据。 “随机访问” 翻译不确切，应该说是任意访问。 RandomAccessFile 有一个最大的局限，就是只能读写文件，不能读写其他 IO 节点。有如下两个方法来操作文件记录指针： long getFilePoint()：返回文件记录指针的位置。 void seek(long pos)：将文件记录指针定位到 pos 位置。 RandomAccessFile 类有两个构造器，一个使用 String 参数来指定文件名，一个使用 File 参数来指定文件本身。另外，创建 RandomAccessFile 对象时还需要指定一个 mode 参数，该参数指定访问 RandomAccessFile 的访问模式。mode 参数有 4 个值： r：以只读模式打开指定文件。 rw：以读、写方式打开指定文件，如果该文件尚不存在，则尝试创建该文件。 rws：以读、写方式打开指定文件。该模式要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。 rwd：以读、写方式打开文件。该模式要求文件内容的每个更新都同步写入到底层存储设备。 File 类File 类是 java.io 包下与平台无关的文件和目录，不管是文件还是目录都是使用 File 类来操作。File 类能新建、删除、重命名文件和目录，但是不能访问文件内容本身(访问内容需要输入/输出流)。 访问文件和目录File 类使用文件路径字符串来创建 File 实例，可以是绝对路径或者相对路径。以下是 File 类提供来操作文件和目录的方法： String getName()：返回此 File 对象所表示的文件名或路径名。 String getPath()：返回此 File 对象所对应的路径名。 File getAbsoluteFile()：返回此 File 对象的绝对路径。 String getParent()：返回此 File 对象所对应目录的父目录名。 boolean renameTo(File newName)：重命名此 File 对象所对应的文件或目录。 boolean exists()：判断 File 对象所对应的文件或目录是否存在。 boolean canWrite()：判断 File 对象所对应的文件和目录是否可写。 boolean canRead()：判断 File 对象所对应的文件和目录是否可读。 boolean isFile()：判断 File 对象所对应的是否是文件，而不是目录。 boolean isDirectory()：判断 File 对象所对应的是否是目录，而不是文件。 boolean isAbsolute()：判断 File 对象所对应的文件或目录是否是绝对路径。 long lastModified()：返回文件的最后修改时间。 long length()：返回文件内容的长度。 boolean createNewFile()：当此 File 对象所对应的文件不存在时，该方法将新建一个该 File 对象所指定的新文件。 boolean delete()：删除 File 对象所对应的文件或路径。 static File createTempFile(String prefix,String suffix)：在默认的临时文件目录中创建一个临时的空文件。 static File createTempFile(String prefix,String suffix,File directory)：在 directory 所指定的目录中创建一个临时的空文件。 void deleteOnExit()：注册一个删除钩子，指定当Java虚拟机退出时，删除 File 对象所对应的文件和目录。 boolean mkdir()：试图创建一个 File 对象所对应的目录，必须对应一个路径，而不是一个文件。 String[] list()：列出 File 对象的所有子文件名和路径名，返回 String 数组。 File[] listFile()：列出 File 对象的所有子文件和路径，返回 File 数组。 static File[] listRoots()：列出系统所有的根路径。 注意：Windows的路径分隔符使用反斜线(\)，而Java程序中的反斜线表示转移字符，所有当需要在Windows的路径下包括反斜线，应该使用两条反斜线，或者直接使用斜线(/)。 文件过滤器File 类的 list() 方法中可以接受一个 FilenameFilter 参数，通过该参数可以只列出符合条件的文件。该 FilenameFilter 接口包含了一个 accept(File dir,String name) 方法，该方法将依次对指定 File 的所有子目录或文件进行迭代，如果该方法返回 true，则 list() 方法会列出该子目录或文件。 123456File file = new File("D:/MyWork");String[] nameList = file.list((dir, name) -&gt; name.endsWith(".jpg"));for (String str:nameList)&#123; System.out.println(str);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10-异常处理]]></title>
    <url>%2F2018%2F03%2F13%2FJava%2F10-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[在 Java 中，异常对象都是派生于 Throwable 类的一个实例。如果 Java 中内置的异常类不能满足需求，用户还可以创建自己的异常类。派生于 Error类 或 RuntimeException类 的所有异常称为 非受查异常(unchecked)；所有其他的异常称为 受查异常(checked)，这是可以在编译阶段被处理的异常，所以它强制程序处理所有的 Checked异常。 Error 错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。应用程序无须处理这些错误。 使用 try…catch 捕获异常123456789try&#123; //业务实现代码 ....&#125;catch(Exception e)&#123; //处理异常&#125; 如果执行 try 块里的业务逻辑代码时出现异常，系统自动生成一个异常对象，该异常对象被提交给 Java 运行时环境，这个过程被称为 抛出(throw)异常。 当 Java 运行时环境收到异常对象时，会寻找能处理该异常对象的 catch 块，如果找到合适的 catch 块，则把异常对象交给该 catch 块处理，这个过程被称为捕获（catch）异常；如果Java运行时环境找不到捕获异常的 catch 块，则运行时环境终止，Java程序也将退出。 不管程序代码是否处于 try 块中，甚至包括 catch 块中的代码，只要执行该代码块时出现了异常，系统总会产生一个异常对象。如果程序没有为这段代码定义任何的 catch 块，则Java运行时环境无法找到处理该异常的 catch 块，程序就在此退出。 在进行异常捕获时应该把所有父类异常的 catch 块排在子类异常 catch 块的后面，简称：先处理小异常，再处理大异常。通常情况下，如果 try 块被执行一次，则只有一个 catch 块会被执行，绝不可能有多个 catch 块被执行。 Java7提供的多异常捕获从Java7开始，一个 catch 块可以捕获多种类型的异常，但需要注意两个地方： 捕获多种类型的异常时，多种异常类型之间用竖线 （|） 隔开。 捕获多种类型的异常时，异常变量有隐式的 final，因此程序不能对异常变量重新赋值。 以下程序示范了多异常捕获：123456789101112131415161718192021try&#123; int a=Integer.parseInt(args[0]); int b=Integer.parseInt(args[1]); int c=a/b; System.out.println(&quot;您输入的两个数相除的结果是：&quot;+ c);&#125;catch(IndexOutOfBoundsException | NumberFormatException | ArithmeticException e)&#123; System.out.println(&quot;程序发生了数组越界、数字格式异常、算数异常之一&quot;); //捕获多异常时，异常变量默认有 final 修饰 //所以下面代码会出错 e=new ArithmeticException(&quot;test&quot;);&#125;catch(Exceptioon e)&#123; System.out.pritnln(&quot;未知异常&quot;); //捕获一种未知的异常，该异常变量没有 final 修饰 //所以下面代码正确 e=new RuntimeException(&quot;test);&#125; 访问异常信息如果程序需要在 catch 中访问异常对象的相关信息，则可以通过访问 catch 块括号里面的异常形参来获得，所有的异常对象都包含了如下几个常用方法： getMessage()：返回该异常的详细描述字符串。 printStackTrace()：将该异常的跟踪栈信息输出到标准错误输出。 printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流。 getStackTrace()：返回该异常的跟踪栈信息。 使用 finally 回收资源因为 Java 的垃圾回收机制不会回收任何物理资源，垃圾回收机制只能回收堆内存中对象所占用的内存，所以程序在 try 块里打开的物理资源(如数据库连接、网络连接和磁盘文件)，必须要显式回收。 除非在 try 块、catch 块中调用了退出虚拟机的方法，否则不管在 try 块、catch 块中执行怎样的代码，出现怎样的情况，异常处理的 finally 块总会被执行。 因此，当 Java 程序执行 try 块、catch 块时遇到了 return 或 throw 语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句不会结束该方法，而是去寻找该异常处理流程中是否包含 finall 块，如果没有 finall 块，程序立即执行 return 或 throw 语句，方法终止；如果有 finally 块(finally中没有return或throw)，系统立即开始执行 finall 块。当 finall 块完成后，系统才会再次跳转回来执行 try块、catch块里的 return 或 throw 语句。如果 finall 块里也使用了 return 或 throw 等导致方法终止的语句，将会导致 try块、catch块 中的 return、throw 语句失效。 自动关闭资源的 try 语句从 Java7 开始，允许在 try 关键字后紧跟一堆圆括号，圆括号内可以声明、初始化一个或多个资源(资源指的是必须在程序结束时显式关闭的资源，比如数据库连接、网络连接等)，try 语句在该语句结束时自动关闭这些资源。但这些资源实现类必须实现 AutoCloseable 或 Closeable 接口，实现这两个接口就必须实现 close()方法。 Closeable 是 AutoCloseable 的子接口。Closeable 接口里的 close() 方法声明抛出了 IOException，因此它的实现类在实现 close() 方法时只能声明抛出 IOException 或其子类；AutoCloseable 接口里的 close() 方法声明抛出了 Exception ，因此它的实现类在实现 close() 方法时可以声明抛出任何异常。 使用 throws 声明抛出异常使用 throws 声明抛出异常的思路是，当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理；如果 main 方法也不知道如何处理这种类型的异常，也可以使用 throws 声明抛出异常，该异常将交给 JVM 处理。JVM 对异常的处理方法是：打印异常的跟踪栈信息，并终止程序运行。 如果某段代码中调用了一个带 throws 声明的方法，该方法声明抛出了 Checked异常，则表明该方法希望它的调用者来处理该异常。也就是说，调用该方法时要么放在try 块中显式捕获该异常，要么放在另一个带 throws 声明抛出的方法中。 使用 throws 声明抛出异常时有一个限制：子类方法声明抛出的异常类型应该时父类方法声明抛出的异常类型的子类或相同，子类方法声明抛出的异常不允许比父类方法声明抛出的异常多。 使用 throw 抛出异常Java允许程序自行抛出异常，使用 throw 语句来完成。1throw ExceptionInstance; 当 Java 运行时接收到开发者自行抛出异常时，同样会中止当前的执行流，跳到该异常对应的 catch 块，由该 catch 块来处理该异常。 自定义异常类自定义异常应该继承 Exception 类，或者继承 Exception 类的子类。自定义异常应该包含两个构造器：一个是无参数的默认构造器；另一个是带有详细描述信息字符串的构造器，这个字符串将作为异常对象的 getMessage() 方法的返回值。1234567891011public class MyException extends Exception&#123; //无参数构造器 public MyException()&#123;&#125; //带有字符串参数的构造器 public MyException(String msg) &#123; super(msg); &#125;&#125; catch 和 throw 同时使用在实际应用中对异常的处理往往更复杂，当一个异常出现时，单靠某个方法无法完全处理该异常，必须由几个方法协作才可以完全处理该异常。也就是说，在异常出现的当前方法中，程序只对异常进行部分处理，还有些处理需要在该方法的调用者中才能完成，所以应该再次抛出异常，让该方法的调用者也能捕获异常。 为了实现这种通过多个方法协作处理同一个异常的情形，可以在 catch 块中结合 throw 语句来完成：12345678910111213141516//声明要抛出的异常 anotherExceptionpublic void method() throws anotherException&#123; try &#123; throw Exception(); &#125; catch(Exception e) &#123; //此处完成本方法中可以对异常执行的修复处理 e.printStackTrace(); //再次抛出同一个异常 throw new anotherException(); &#125;&#125; 这种 catch 和 throw 结合使用的情况可以用在：① 应用后台需要通过日志来记录异常发送的详细情况。② 应用还需要根据异常向应用使用者传达某种提示。 Java7增强的 throw 语句先看这一段代码：123456789try&#123; throw new FileOutputStream(&quot;a.txt&quot;);&#125;catch(Exception ex)&#123; ex.printStackTrace(); trow ex; //① 这里再次抛出捕获到的异常&#125; 上面的代码在 catch 块中再次抛出了捕获到的异常，但这个 ex 对象比较特殊：程序捕获该异常时，声明该异常的类型为 Exception，但实际上 try 块中可能只调用了 FileOutputStream 构造器，这个构造器只是声明抛出了 FileNotFoundException 异常。利用 Exception 捕获，显然是大材小用。 从 Java7 开始，Java 编译器会执行更细致的检查，Java 编译器会检查 throw 语句抛出异常的实际类型，这样编译器知道 ① 代码处实际抛出的是 FileNotFoundException 异常。因此在调用该段代码的方法签名中只需要声明抛出 FileNotFoundException 异常即可。 异常链在真实的应用程序中，有严格的分层关系，层与层之间有非常清晰的划分，上层功能的实现严格依赖于下层的 API，也不会跨层访问。对于上图所示结构的应用，当业务逻辑层访问持久层出现 SQLException 异常时，程序不应该把底层的 SQLException 异常传到用户界面。通常的做法是：程序先捕获原始异常，然后抛出一个新的业务异常，新的业务异常中包含了对用户的提示信息，这种处理方式被称为 异常转译。 假设程序需要实现工资计算的方法，则程序应该采用如下结构的代码实现：12345678910111213141516171819202122public void calSalary() throws SalaryException&#123; try &#123; //实现结算工资的业务逻辑 ....... &#125; catch(SQLException sqle) &#123; //把原始异常记录下来，留给管理员 .... //下面异常中的message就是对用户的提示 throw new SalaryException(&quot;访问底层数据库出现异常&quot;); &#125; catch(Exception e) &#123; //把原始异常记录下来，留给管理员 .... //下面异常中的message就是对用户的提示 throw new SalaryException(&quot;系统出现未知异常&quot;); &#125;&#125; 以上代码把原始异常信息隐藏起来，仅向上提供必要的异常提示信息的处理方式，可以保证底层异常不会扩散到表现层，可以避免向上暴露太多的实现细节，这符合面向对象的封装原则。 这种把捕获一个异常然后接着抛出另一个异常，并把原始异常信息保存下来是一种典型的链式处理，也被称为 “异常链”。 所有 Throwable 的子类在构造器中都可以接收一个 cause 对象作为参数。这个 cause 就用来表示原始异常，这样就可以把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，你也能通过这个 异常链 追踪到异常最初发生的位置。 例如希望通过上面的 SQLException 去追踪到最原始的异常信息，则可以将方法改写：12345678910111213141516171819202122public void calSalary() throws SalaryException&#123; try &#123; //实现结算工资的业务逻辑 ....... &#125; catch(SQLException sqle) &#123; //把原始异常记录下来，留给管理员 .... //下面异常中的message就是对用户的提示 throw new SalaryException(sqle); //此处不同 &#125; catch(Exception e) &#123; //把原始异常记录下来，留给管理员 .... //下面异常中的 e 就是对用户的提示 throw new SalaryException(e); &#125;&#125; 上面的代码在创建 SQLException 对象时，传入了一个 Exception 对象，而不是传入了一个 String 对象，这就需要 SQLException 类有对应的构造器：123456789101112public class SalaryException extends Exception&#123; public SalaryException()&#123;&#125; public SalaryException(String msg)&#123;&#125; //创建一个可以接收 Throwable 参数的构造器 public SalaryException(Throwable t) &#123; super(t); &#125;&#125; 创建了这个 SalaryException 业务异常类后，就可以用它来封装原始异常，从而实现对异常的链式处理。 异常处理规则成功的异常处理规则应该实现如下 4 个目标： 使程序代码混乱最小化。 捕获并保留诊断信息。 通知合适的人员。 采用合适的方式结束异常活动。 要达到以上目标，要做到： 不要过度使用异常。 不要使用过于庞大的 try 块。 避免使用 Catch All 语句。 不要忽略捕获到的异常。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-Java集合框架]]></title>
    <url>%2F2018%2F03%2F12%2FJava%2F8-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Java集合大致可分为 Set、List、Queue 和 Map 四种体系。所有的集合类都位于 java.util 包下，为了处理多线程下环境下的并发安全问题，从Java5开始还在 java.util.concurrent 包下提供了一些多线程支持的集合类。Java的集合类主要由两个接口派生：Collection 和 Map，是Java集合框架的根接口。 Collection 和 Iterator 接口Collection 接口是 List、Set 和 Queue 接口的父接口，定义了如下操作集合元素的方法： boolean add(Object o)：向集合里添加一个元素。 boolean addAll(Collection c)：把集合 c 里所有的元素添加到指定集合里。 void clear()：清除集合里的所有元素，将集合长度重置为0。 boolean contains(Object o)：返回集合里是否包含指定元素。 boolean containsAll(Collection c)：返回集合里是否包含集合 c 里的所有元素。 boolean isEmpty()：返回集合是否为空。 Iterator iterator()：返回一个 Iterator 对象，用于遍历集合里的元素。 boolean remove(Object o)：删除集合中的指定元素，当集合中包含了一个或多个元素 o 时，该方法只删除第一个符合条件的元素。 boolean removeAll(Collection c)：从集合中删除集合 c 里的所有元素。 boolean retainAll(Collection c)：把调用该方法的集合变成该集合和集合 c 的交集。 int size()：该方法返回集合里元素的个数。 Object[] toArray()：该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。 使用 Lambda 表达式遍历集合和迭代器Java8为 Iterator 接口新增了一个 forEach(Consumer action) 默认方法，该方法所需参数是一个函数式接口，而 Iterator 接口是 Collection 接口的父接口，因此 Collection 集合也可以直接调用该方法。1books.forEach(obj-&gt;System.out.println(&quot;迭代元素：&quot; + obj )); 使用 Java8 增强的 Iterator 遍历元素Iterator 主要用于遍历 Collection 集合中的元素，接口里定义了4个方法： boolean hasNext()：如果被迭代的集合元素还没有被迭代完，返回true。 Object next()：返回集合里的下一个元素。 void remove()：删除集合里上一次 next() 方法返回的元素。 void forEachRemaining(Cosumer action)：使用 Lambda 表达式来遍历集合元素。 使用 Lambda表达式遍历 Iterator使用 Iterator 新增的方法 forEachRemaining(Consumer action) 方法来遍历迭代器：12Iterator it=books.iterator();it.forEachRemaining(obj -&gt; System.out.println(&quot;迭代集合元素：&quot; + obj)); Java8 新增的 Predicate 操作集合Java8为 Collection 集合新增了一个 removeIf(Predicate filter) 方法，该方法将会批量删除符合 filter 条件的所有元素。Predicate 也是函数式接口：1books.removeIf(ele-&gt;((String)ele).length()&lt;10); 操作集合的工具类：CollectionsJava 提供了一个操作 Set、List 和 Map 等集合的工具类：Collections，该工具类里提供了大量方法对集合元素进行排序、查询和修改等操作，还提供了将集合对象设置为不可变类、对集合对象实现同步控制等方法。 排序操作Collections 提供了如下类方法用于对 List 集合元素进行排序： void reverse(List list)：反转指定 List 集合中元素的顺序。 void shuffle(List list)：对 List 集合元素进行随机排序( shuffle 方法模拟了 “洗牌” 动作)。 void sort(List list)：根据元素的自然顺序对指定 List 集合的元素按升序进行排序。 void sort(List list,Comparator c)：根据指定 Comparator 产生的顺序对 List 集合元素进行排序。 void swap(List list,int i,int j)：将指定 List 集合中的 i 处元素和 j 处元素进行交换。 void rotate(List list,int distance)：当 distance 为正数时，将 list 集合的后 distance 个元素 “整体” 移到后面；当 distance 为负数时，将 list 集合的前 distance 个元素 “整体” 移到后面。 查找、替换操作 同步控制Collections 类中提供了多个 synchronizedXxx() 方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。 Java中常用的集合框架中的实现类 HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap 和 TreeMap 都是线程不安全的。如果有多个线程访问并试图修改它们，则存在线程安全问题。Collections 提供了多个类方法可以把它们包装成线程同步的集合。1234Collection c=Collections.synchonizedCollection(new ArrayList());List list=Collections.synchronizedList(new ArrayList());Set s=Collection.synchronizedSet(new HashSet());Map m=Collections.synchronizedMap(new HashMap()); 设置不可变集合Collections 提供了如下三个类方法来返回一个不可变集合： emptyXxx()：返回一个空的、不可变的集合对象，此处的集合既可以是 List，也可以是 SortedSet、Set，还可以是 Map、SortedMap 等。 singletonXxx()：返回一个只包含指定对象（只有一个元素或一项元素)的、不可变的集合对象，此处的集合既可以是 List、也可以是 Map。 unmodifiableXxx()：返回指定集合对象的不可变试图，此处的集合既可以是 List，也可以是 Set、Sorted Set，还可以是 Map、SortedMap 等。 上面的方法的参数是原有的集合对象，返回值是该集合的 “只读” 版本。通过 Collections 提供的方法，可以生成 “只读” 的 Collection 或 Map。 操作集合的工具类：Collections工具类 Collections 提供了大量方法对集合元素进行排序、查询和修改，还提供了将集合对象设置为不可变、对集合对象实现同步控制等方法。 排序操作Collections 提供了如下静态方法用于对 List 集合进行排序： void reverse(List list)：反转指定 List 集合中元素的顺序。 void shuffle(List list)：对 List 集合元素进行随机排序(shuffle 方法模拟了 “洗牌” 动作)。 void sort(List list)：根据元素的自然顺序对指定 List 集合的元素按升序进行排序。 void sort(List list,Comparator c)：根据指定 Comparator 产生的顺序对 List 集合元素进行排序。 void swap(List list,int i,int j)：将指定 List 集合中的 i 位置的元素和 j 位置的元素进行交换。 void rotate(List list,int distance)：当 distance 为正数时，将 list 集合的后 distance 个元素 “整体” 移到前面；当 distance 为负数时，将 list 集合的前 distance 个元素 “整体” 移到到后面。该方法不会改变集合长度。 查找、替换操作Collections 提供了用于查找、替换集合元素的类方法：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-日期、数字的格式化]]></title>
    <url>%2F2018%2F03%2F12%2FJava%2F7-%E6%97%A5%E6%9C%9F%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[使用 NumberFormat 格式化数字抽象类 Format 有子类：MessageFormat、NumberFormat、DateFormat。NumberFormat、DateFormat 可以将数值、日期转换成字符串，也可以将字符串转换成数值、日期。 NumberFormat 和 DateFormat 类都包含了 format() 和 parse() 方法，其中 format() 用于将 数值、日期 格式化成字符串，parse() 用于将字符串解析成数值、日期。 NumberFormat 是一个抽象基类，提供了如下几个类方法来得到对象： getCurrencyInstance()：返回默认 Locale 的货币格式器，也可以在调用该方法时传入指定的 Locale，则获取指定 Locale 的货币格式器。 getIntegerInstance()：返回默认 Locale 的整数格式器，也可以在调用该方法时传入指定的 Locale，则获取指定 Locale 的货币格式器。 getNumberInstance()：返回默认 Locale 的通用数值格式器，也可以在调用该方法时传入指定的 Locale，则获取指定 Locale 的货币格式器。 getPercentInstance()：返回默认 Locale 的百分数格式器，也可以在调用该方法时传入指定的 Locale，则获取指定 Locale 的货币格式器。 一旦取得 NumberFormat 对象后，就可以调用它的 format() 方法来格式化数值，包括整数和浮点数。 使用 DateFormat 格式化日期、时间DateFormat 也是一个抽象类，提供如下几个类方法用于获取 DateFormat 实例： getDateInstance()：返回一个日期格式器，它格式化后的字符串只有日期，没有时间。该方法可以传入多个参数，用于指定日期样式和 Locale 等参数，不指定就使用默认参数。 getTimeInstance()：返回一个时间格式器，它格式化后的字符串只有时间，没有日期。该方法可以传入多个参数，用于指定日期样式和 Locale 等参数，不指定就使用默认参数。 getDateTimeInstance()：返回一个日期、时间格式器，它格式化后的字符串既有日期，也有时间。该方法可以传入多个参数，用于指定日期样式、时间样式和 Locale 等参数，不指定就使用默认参数。 可以通过 DateFormat 的 4 个静态常量指定日期、时间样式： FULL：例如 Friday，December 2，2018 LONG：例如 December 2，2018 MEDIUM：例如 Dec 2，2018 SHORT：例如 12/2/18 123456789//需要被格式化的时间Date dt = new Date();//创建不同的日期格式器DateFormat shortDf=DateFormat.getDateInstance(DateFormat.SHORT);DateFormat fulltDf=DateFormat.getDateInstance(DateFormat.FULL);//开始格式化System.out.println(shortDf.format(dt));System.out.pritnln(fullDf.format(dt)); 获得了 DateFormat 对象之后，还可以调用它的 setLenient(boolean lenient) 方法类设置该格式器是否采用严格语法DateFormat 的 parse() 方法可以把一个字符串解析成 Date 对象。 使用 SimpleDateFormat 格式化日期SimpleDateFormat 是 DateFormat 的子类，创建 SimpleDateFormat 对象时需要传入一个 pattern 字符串，是一个日期模板字串，用来定制自己的日期格式。12345//定制自己的日期格式String pattern = &quot;YYYY/MM/dd&quot;;SimpleDateFormat dateFomat = new SimpleDateFormat(pattern);System.out.println(dateFormat.format(new Date()); Java8 新增的日期、时间格式器Java8 新增的日期、时间API里不仅包括了 Instant、LocalDate、LocalDateTime、LocalTime 等代表日期、时间的类，而且在 java.time.format 包下提供了一个 DateTimeFormatter 格式器类，该类相当于前面介绍的 DateFormat 和 SimpleDateFormat 的合体，功能非常强大。 创建格式器实例首先获取 DateTimeFormatter 对象，途径有： 直接使用静态常量创建格式器：ISO_LOCAL_DATE、ISO_LOCAL_TIME、ISO_LOCAL_DATE_TIME 等静态常量，这些静态常量本身就是 DateTimeFormat 实例。 使用代表不同风格的枚举值来创建格式器，在 FormatStyle 枚举类中定义了 FULL、LOGN、MEDIUM、SHORT 四个枚举值。 根据模式字符串来创建格式器。 完成格式化使用 DateTimeFormatter 把日期、时间格式化为字符串： 调用 format(TemporalAccessor temporal) 方法执行格式化，LocalDate、LocalDateTime、LocalTime 等类都是 TemporalAccessor 接口的实现类。 调用 LocalDate、LocalDateTime、LocalTime 等日期、时间对象的 format(DateTimeFormatter formatter) 方法执行格式化。 解析字符串将指定格式的字符串解析成日期、时间对象，通过日期、时间对象提供的 parse(CharSequence text,DateTimeFormatter formatter) 方法进行解析。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-国际化]]></title>
    <url>%2F2018%2F03%2F12%2FJava%2F7-%E5%9B%BD%E9%99%85%E5%8C%96%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[国际化的思路Java 程序的国际化思路是将程序中的标签、提示等信息放在资源文件中，程序需要支持哪些国家、语言环境，就对应提供相应的资源文件。资源文件是 key-value 对，每个资源文件中的 key 是不变的，但 value 则随不同的国家、语言而改变。 Java程序的国际化主要通过如下三个类完成： java.util.ResourceBundle：用于加载国家、语言资源包。 java.util.Locale：用于封装特定的国家/区域、语言环境。 java.text.MessageFormat：用于格式化带占位符的字符串。 资源文件的内容是很多的 key-value 对，其中 key 是程序使用的部分，而 value 则是程序界面的显式字符串。资源文件的命名可以有如下三种形式： baseName_language_contry.properties baseName_language.properties baseName.properties baseNaem 是资源文件的基本名，可以随意指定；而 language 和 country 都不可随意变化，必须是Java支持的语言和国家。12345678//返回Java所支持的全部国家和语言的数组Local[] localList=Locale.getAvailableLocales();//遍历数组的每个元素，依次获取所支持的国家和语言for (int i=0;i&lt;localeList.length;i++)&#123; System.out.println(localeList[i].getDisplayCountry()+&quot;=&quot;+localeList[i].getCountry()+&quot; &quot;+ localeList[i].getDisplayLanguage()+&quot;=&quot;+localeList[i].getLanguage());&#125; 完成国际化的步骤准备资源文件为程序提供两个文件：第一个文件：mess.properties，其内容为：12#资源文件的内容是 key-value 对hello=你好！ 第二个文件：mess_en_US.properties，该文件的内容为：12#资源文件的内容是 key-value 对hello=Welcome! 对于包含非西欧字符的资源文件，Java提供了一个工具来处理该文件：native2ascii，这个工具可以在 %JAVA_HOME%/bin 路径下找到，使用该工具的语法格式如下：1native2ascii 资源文件 目的资源文件 在命令窗口输入如下命令：1native2ascii mess.properties mess_zh_CN.properties 上面的命令将生成一个 mess_zh_CN.properties 文件，该文件才是程序需要的资源文件，该文件里面是非西欧字符的 Unicode 编码方式。 进行国际化12345678//取得系统默认的国家/语言环境Locale myLocale=Locale.getDefault(Locale.Category.FORMAT);//关键：根据指定的国家/语言环境加载资源文件ResourceBundle bundle=ResourceBundle.getBundle(&quot;mess&quot;,myLocale);//打印从资源文件中取得的消息System.out.println(bundle.getString(&quot;hello&quot;); 注意该代码：12//根据指定的国家/语言环境加载资源文件ResourceBundle bundle=ResourceBundle.getBundle(&quot;mess&quot;,myLocale); 上面代码将会加载 baseName 为 mess 的系列资源之一，到底加载其中的哪个资源文件，则取决于 myLocale ；对于简体中文的 Locale ，则加载 mess_zh_CN.properties 文件。 使用 MessageFormat 处理包含占位符的字符串前面程序输出的消息是一个简单信息，如果需要输出的消息中必须包含动态的内容，例如，这些内容必须是从程序中取得的：1你好，yeeku！今天是 2018-03-12 上午 10:24 上面的输出字符串中，yeeku 是用户的名字，必须动态改变，后面的时间也必须动态改变。在这种情况先，可以使用带占位符的消息。 例如，提供一个 myMess_en_US.properties 文件，该文件内容如下：1msg=Hello，&#123;0&#125;！Today is &#123;1&#125;. 提供一个 myMess.properties 文件，内容如下：1msg=你好，&#123;0&#125;! 今天是 &#123;1&#125;。 现在，程序需要为 {0} 和 {1} 两个占位符赋值，此时需要使用 MessageFormat 类，该类包含了一个静态方法： format(String pattern,Object… values)：返回后面的多个参数值填充前面的 patter 字符串，其中 pattern 是一个带占位符的字符串。12345678910111213141516171819//定义一个 Locale 变量Locale currentLocale = null;//如果运行程序指定了两个参数if(args.length == 2)&#123; //使用运行程序的两个参数构造 Locale 实例 currentLocale = new Locale(args[0],args[1]);&#125;else&#123; //否则直接使用系统默认的 Locale currentLocale = Locale.getDefault(Locale.Catefory.FORMAT);&#125;//根据 Locale 加载语言资源ResourceBundle bundle = ResourceBundle.getBundle(&quot;myMess&quot;,currentLocal);//取得已加载的语言资源文件中的 msg 对应消息String msg = bundle.getString(&quot;msg&quot;);//使用 MessageFormat 为带占位符的字符串传入参数System.out.println(MessageFormat.format(msg,&quot;yeeku&quot;,new Date()); 使用类文件代替资源文件除了使用属性文件作为资源文件外，Java也允许使用类文件代替资源文件，即将所以的 key-value 对存入 class 文件，而不是属性文件。 使用类文件来代替资源文件必须满足以下条件： 该类的类名必须是 baseName_language_country，这与属性文件的命名方式相似。 该类必须继承 ListResourceBundle，并重写 getContents() 方法，该方法返回 Object数组，该数组的每一项都是 key-value 对。以下是一个简体中文语言环境的资源文件，可以替代 Mess_zh_CN.properties。当系统同时存在资源文件、类文件时，以类文件为主。 123456789101112131415public class Mess_zh_CN extends ListResourceBundle&#123; //定义资源 private final Object myDate[][] = &#123; &#123;"msg"，" &#123;0&#125;，你好！今天的日期是 &#123;1&#125; "&#125; &#125;; //重写 getContents() 方法 public Object[][] getContents() &#123; //该方法返回资源的 key-value 对 return myDate; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中正则表达式]]></title>
    <url>%2F2018%2F03%2F12%2FJava%2FJava%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式是一个用于匹配的模板，可以对字符串进行查找、提取、分割、替换等操作。String 类里也提供了几个特殊的方法： boolean matches(String regex)：判断字符串是否匹配指定的正则表达式。 String replaceAll(String regex，String replacement)：将字符串中所有匹配 regex 的子串替换成 replacement。 String replaceFirst(String regex，String replacement)：将字符串中第一个匹配 regex 的子串替换成 replacement。 String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串 除此之外，Java还提供了 Pattern 和 Matcher 两个类专门用于提供正则表达式支持。 创建正则表达式前面介绍，正则表达式就是一个用于匹配字符串的模板，可以匹配一批字符串，所以创建正则表达式就是创建一个特殊的字符串。除此之外，正则表达式中有一些特殊字符，这些特殊字符在正则表达式中有特殊的用途，比如反斜线（\）。如果需要匹配这些特殊字符，就必须首先将这些字符转义。正则表达式中还能使用通配符，通配符可以匹配多个字符，又称为预定义字符。提示：d 是 digit 的意思，代表数字；s 是 space 的意思，代表空白；w 是 word 的意思，代表单词；d、s、w 的大写形式切好匹配与之相反的字符。 特殊情况下还能使用方括号表达式： 正则表达式还支持圆括号表达式，用于将多个表达式组成一个子表达式，圆括号中可以使用 或运算符 (|)。例如，正则表达式 ((public)|(protected)|(private)) 用于匹配Java的三个访问控制符其中之一。 除此之外，Java正则表达式还支持几个边界匹配符： 当需要建立一个匹配 000-0000-0000 形式的电话号码时，使用了 \\d\\d\\d-\\d\\d\\d\\d-\\d\\d\\d\\d 正则表达式，这看起来比较繁琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式： Greedy(贪婪模式)：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的正则表达式会一直匹配下去，直到无法匹配为止。 Reluctant(勉强模式)：用问号后缀 (?) 表示，它只会匹配最少的字符，也称为最小匹配模式。 Prossesive(占有模式)：用加号后缀（+）表示，目前只有Java支持占有模式，通常比较少用。 三种模式的数量表示符如下： 使用正则表达式一旦在程序中定义了正则表达式，就可以使用 Pattern 和 Matcher 来使用正则表达式。 Pattern 对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为 Pattern 对象，然后再利用该 Pattern 对象创建对应的 Matcher 对象。执行匹配所涉及的状态保留在 Matcher 对象中，多个 Matcher 对象可共享同一个 Pattern 对象。12345//将一个字符串正则表达式编译成 Pattern 对象Pattern pattern=Pattern.compile(&quot;a*b&quot;);//a*b 为正则表达式//使用 Pattern 对象创建 Matcher 对象Matcher matcher= pattern.matcher(&quot;aaaaab&quot;);//aaaaab 为需要查找的文本字符串boolean b=m.matches();//返回 true Matcher 类提供了如下几个常用的方法： find()：返回目标字符串中是否包含与 Pattern 匹配的子串。 group()：返回上一次与 Pattern 匹配的子串。 start()：返回上一次与 Pattern 匹配的子串在目标字符串中的开始位置。 end()：返回上一次与 Pattern 匹配的子串在目标字符串中的结束位置加1。 lookingAt()：返回目标字符串前面部分与 Pattern 是否匹配。 matches()：返回整个目标字符串与 Pattern 是否匹配。 reset()：将现有的 Matcher 对象应用于一个新的字符序列。 通过 Matcher 类的 find() 和 group() 方法可以从目标字符串中依次取出特定子串(匹配正则表达式的子串)，例如网络爬虫，可以自动从网页中识别出所有的电话号码。1234567891011//使用字符串模拟从网络上得到的网页源码String str = &quot;我想求购一本《疯狂 Java 讲义》，尽快联系我 13500006666&quot; + &quot;交朋友，电话号码是 13611125565&quot; + &quot;出售二手电脑，联系方式是 15899903312&quot;;//创建一个 Pattern 对象，并用它建立一个 Matcher 对象//该正则表达只抓取 13X 和 15X 段的手机号//实际要抓取哪些电话号码，只要修改正则表达式即可Matcher matcher = Pattern.compile(&quot;((13\\d) | (15\\d)) \\d&#123;8&#125;&quot;).matcher(str);//将所有符号正则表达式的子串(电话号码)全部输出while(matcher.find())&#123; System.out.println(matcher.group());&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3-数据类型和运算符]]></title>
    <url>%2F2018%2F03%2F11%2FJava%2F3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[文档注释文档注释以斜线后紧跟两个星号 /** 开始，以星号后紧跟一个斜线 */ 结束。 使用 javadoc 工具提取程序的文档注释来生成 API 文档：1javadoc 选项 Java源文件|包 javadoc 命令可对源文件、包生成 API 文档，Java源文件可以支持通配符，例如 *.java 来代表当前路径下的所有 Java源文件。 javadoc 常用的选项有如下几个： -d &lt;directory&gt;：该选项指定一个路径，用于将生成的 API 文档放到指定目录下。 -windowtitle &lt;text&gt;：该选项指定一个字符串，用于设置 API 文档的浏览窗口标题。 -doctitle &lt;html-code&gt;：该选项指定一个 HTML 格式的文本，用于指定概述页面的标题。 -header &lt;html-code&gt;：该选项指定一个 HTML 格式的文本，包含每个页面的页眉。 示例：1javadoc -d apidoc -windowtitle 测试 -doctitle 学习javadoc工具的测试API文档 -header 我的类 *.java 如果希望 javadoc 工具生成更详细的文档信息，例如为方法参数、方法返回值等生成详细的说明信息，则可以利用 javadoc 标记。常用的 javadoc 标记 如下： @author：指定 Java 程序的作者。 @version：指定源文件的版本。 @deprecated：该标记表明所标记的方法不推荐使用。 @param：方法的参数说明信息。 @return：方法的返回值说明信息。 @see：”参见”，用于指定交叉参考的内容。 @exception：抛出异常的类型。 @throws：抛出的异常，和 @exception 同义。 这些标记的使用是有位置限制的。可以出现在类或者接口文档注释中的有 @see、@deprecated、@author、@version 等；可以出现在方法或构造器文档注释中的有 @see、@deprecated、@param、@return、@throws 和 @exception 等；可以出现在成员变量的文档注释中的有 @see、@deprecated等。 javadoc 工具默认不会提取 @author 和 @version 两个标记的信息，但是如果需要提取这两个标记的信息，应该在使用 javadoc 工具时指定 -author 和 -version 两个选项。 API 文档中的包注释并不是直接放在 Java源文件中的，而是必须另外指定，通常通过一个标准的 HTML文件来提供包注释，这个文件被称为 包描述文件。包描述文件的文件名通常是 package.heml。示例：12345- lee 文件夹：包含 JavadocTest.java 文件（该Java类的包为 lee），对应包描述文件 package.html。- yeeku 文件夹：包含 Test.java 文件和 JavadocTagTest.java 文件（这两个Java类的包为 yeeku），对应包描述文件 package.html。在命令行窗口进入 lee 和 yeeku 所在路径，执行如下命令：javadoc -d apidoc -windowtitle 测试 -doctitle 学习javadoc工具的测试API文档 -header 我的类 -version -author lee yeeku 上面命令指定对 lee 包和 yeeku 包来生成 API 文档，而不是对 Java 源文件来生成 API 文档。 基本数据类型 整型 byte：-128(-27) ~ 127(27-1) short：-32768(-215) ~ 32767(215-1) int：-2147483648(-231) ~ 2147483647（231-1) long：(-263) ~ (263-1) 如果直接将一个较小的整数值（在 byte 或 short 类型的范围内）赋给一个 byte 或 short 变量，系统会自动把这个整数值当成 byte 或 short 类型处理。如果使用一个巨大的整数值（超出了 int 类型的范围）时，Java 不会自动把这个整数值当成 long 类型处理。如果希望系统把一个整数值当成 long 类型来处理，应在这个整数值后增加 l 或者 L 作为后缀。 Java 中整数值有4种表示方式：十进制、二进制、八进制 和 十六进制，其中二进制的整数以 0b 或 0B 开头；八进制的整数以 0 开头；十六进制的整数以 0x 或 0X 开头，其中 10 ~ 15 分别以 A ~ F 来表示。 所有数字在计算机底层都是以二进制形式存在。原码是直接将一个数值换算成二进制数。但计算机以补码的形式保存所有的整数。补码的计算规则：正数的补码和原码完全相同，负数的补码是其反码加1；反码是对原码按位取反，只是最高位（符号位）保持不变。 字符型字符型用于表示单个的字符，字符型值必须使用单引号 &#39; 括起来。Java使用 16 位的 Unicode 字符集作为编码方式，支持各种语言的字符。 所谓字符集，就是给所有给所有字符的编号组成总和。ASCII 字符集（支持256个字符编号）16位 Unicode 字符集（支持65536个字符编号） 字符型值有如下三种表示形式： 直接通过单个字符来指定字符型值，’A’，’9’。 通过转义字符表示特殊字符型值，’\n’，’\t’。 直接使用 Unicode 值来表示字符型值，格式是 ‘\uXXXX’，其中 XXXX 代表一个十六进制的整数。字符型值也可以采用十六进制编码方式来表示，范围是 ‘\u0000’ ~ ‘\uFFFF’，一共可以表示 65536 个字符，其中前 256 个( ‘\u0000’ ~ ‘\u00FF’ )字符和 ASCII码中的字符完全重合。 由于计算机底层保存字符时，实际上是保存该字符对应的编号，因此 char 类型的值也可以直接作为整型值来使用，它相当于一个 16 位的无符号整数，范围是 0 ~ 65535。反过来，如果把 0 ~ 65535 范围内的一个 int 整数赋给 char 类型变量，系统会自动把这个 int 整数当成 char 类型来处理。 浮点型Java 的浮点数遵循 IEEE 754 标准，采用二进制数据的科学计数法来表示浮点数，对于 float 型数值，第 1 位是符号位，接下来 8 位表示指数，再接下来的 23 位表示尾数；对于 double 类型数值，第 1 位也是符号位，接下来的 11 位表示指数，再接下来的 52 位表示尾数。 如果需要精确保存一个浮点数，应该使用 BigDecimal 类。 Java的浮点数有两种表示形式： 十进制数形式：例如 5.12、512.0、.512。浮点数必须包含一个小数点，否则会被当作 int 类型处理。 科学计数法形式：例如 5.12e2(即 5.12 × 102)，5.12E2(也是 5.12 × 102)。 只有浮点类型的数值才可以使用科学计数形式来表示。例如，51200 是一个 int 类型的值，但 512E2 则是浮点类型的值。Java的浮点类型默认是 double 类型，5.12f 或 5.12F 才表示一个 float 类型的值。 正无穷大：使用一个正数除以 0 将得到正无穷大，通过 Double 或 Float 类的 POSITIVE_INFINITY 来表示。负无穷大：使用一个负数除以 0 将得到负无穷大，通过 Double 或 Float 类的 NEGATIVE_INFINITY 来表示。非数：0.0 除以 0.0，或对一个负数开方将得到一个非数，通过 Double 或 Float 类的 NaN 来表示。 只有浮点数除以 0 才可以得到正无穷大或负无穷大。如果一个整数除以 0，则会抛出异常 ArithmeticException。 基本类型的类型转换自动类型转换小数转换成大数不损失精度。 强制类型转换大数强制转换成小数会造成精度丢失：(targetType)value 字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型，8个包装类都提供了一个 parseXxx(String str) 静态方法用于将字符串转换成基本数据类型。 表达式类型的自动提升当一个算数表达式中包含多个基本类型的值时，整个算数表达式的数据类型将发生自动提升。规则如下： 所有的 byte类型、short类型 和 char类型 将被提升到 int 类型。 整个算数表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型。 运算符位运算符 &amp;：按位与。当两位同时为 1 时才返回 1。 |：按位或。只要有一位为 1 即可返回 1。 ~：按位非。单目运算符，将操作数的每个位（包括符号位）全部取反。 ^：按位异或。当两位相同时返回 0，不同时返回 1。 &lt;&lt;：左移运算符。 &gt;&gt;：右移运算符。 &gt;&gt;&gt;：无符号右移运算符。 左移运算符是将操作数的二进制码整体左移指定位数，左移后右边空出来的位以0填充；右移运算符有 &gt;&gt;和&gt;&gt;&gt;，对于&gt;&gt;而言，把第一个操作数的二进制码右移指定位数后，左边空出来的位以原来的符号位填充，即如果第一个操作数原来是正数，则左边补0；如果第一个操作数是负数，则左边补1。&gt;&gt;&gt;是无符号右移运算符，它把第一个操作数的二进制码右移指定位数后，左边空出来的位总是以0填充。 进行移位运算时还要遵循以下规则： 对于低于 int 类型（如byte、shor、char）的操作数总是先自动类型转换为 int 类型后再移位； 对于 int 类型的整数移位 a&gt;&gt;b，当 b&gt;32 时，系统会先用 b 对 32 求余（因为int类型只有32位），得到的结果才是真正移位的位数。 对于 long 类型的整数移位 a&gt;&gt;b，当 &gt;64 时，总是先用 b 对64求余（因为long类型是64位），得到的结果才是真正移位的位数。 逻辑运算符 &amp;&amp;：短路与，前后两个操作数必须都是 true 才返回 true。 &amp;`：不断路与。 ||：短路或，只要其中一个操作数是 true 就可以返回 true。 |`：不短路或。 !：逻辑 非。 ^：异或。当两个操作数不同才返回 true。 运算符的结合性和优先级以下是运算符优先级，上一行的运算符总是优先于下一行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-Java8新增的日期、时间类]]></title>
    <url>%2F2018%2F03%2F11%2FJava%2F7-Java8%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java8新增的日期、时间包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//下面是关于 Clock 的用法//获取当前 ClockClock clock=Clock.systemUTC();//使用世界时生成 clock//通过 Clock 获取当前时刻System.out.println(&quot;当前时刻为:&quot;+ clock.instant();//获取 clock 对象对应的毫秒数，与 System.currentTimeMillis() 输出相同System.out.println(clock.millis());System.out.println(System.currentTimeMillis());//--下面是关于 Duration 的用法Duration duration=Duration.ofSeconds(6000);System.out.println(&quot;6000秒相当于&quot;+ duration.toMinutes + &quot;分&quot;);System.out.println(&quot;6000秒相当于&quot;+ duration.toHours() + &quot;小时&quot;);System.out.println(&quot;6000秒相当于&quot;+ duration.toDays() + &quot;天&quot;);//在 clock 对象基础上增加6000秒,返回新的 ClockClock clock2=Clock.offset(clock,duration);//---下面是关于 Instant 的用法//获取当前时间Instant instant=Instant.now();System.out.pritnln(instant);//instant 添加 6000秒(即100分钟),返回新的 InstantInstant instant2=instant.plusSeconds(6000);System.out.println(instant2);//根据字符串解析 Instant 对象Instant instant3=Instant.parse(&quot;2018-03-11T23:12:45.891Z&quot;);System.out.println(instant3);//在 instant3 的基础上添加 5小时4分钟 Instant instant4=instant3.plus(Duration.ofHours(5).plusMinutes(4));System.out.println(instant4);//获取 instant4 的5天以前的时刻Instant instant5=instant4.mimutes(Duration.ofDays(5));System.out.println(instant5);//---下面是关于 LocalDate 的用法LocalDate localDate=LocalDate.now();System.out.println(localDate);//获得2018年的第146天localDate=LocalDate.ofYearDay(2018,146);System.out.println(localDate); //2018-05-26//设置为 2018年5月26日localDate=LocalDate.of(2018,Month.May,26);//---下面是关于 LocalTime 的用法//获取当前时间LocalTime localTime=LocalTime.now();//设置为 22点33分localTime=LocalTime.of(22,33);//返回一天中的第 5503秒localTime=LocalTime.ofSecondofDay(5503);//---下面是关于 LocalDateTime 的用法//获取当前日期、时间LocalDateTime localDateTime=LocalDateTime.now();//当前日期、时间加上25小时3分钟LocalDateTime future=localDateTime.plusHours(25).plusMinutes(3);//---下面是关于 Year、Year Month、MonthDay 的用法Year year=Year.now();//当前年份再加5年year=year.plusYears(5);//根据指定月份获取 YearMonthYearMonth yearMonth=year.atMonth(10);//输出 XXXX-10，XXXX为当前年份//当前年份再加5年、减去3个月year=year.plusYears(5).minusMonths(3);//当前日期MonthDay monthDay=MonthDay.now();//设置为5月23日MonthDay monthDay2=monthDay.with(Month.MAY).withDayOfMonth(23);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6-Enum枚举类]]></title>
    <url>%2F2018%2F03%2F11%2FJava%2F6-Enum%E6%9E%9A%E4%B8%BE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[枚举类基础关键字 enum 用来定义枚举类，地位与 class、interface 相同。枚举类是一种特殊的类，它一样可以有自己的成员变量、方法，可以实现一个或多个接口，也可以定义自己的构造器。 但枚举类终究不是普通类，它与普通类有如下区别： 枚举类默认继承了 java.lang.Enum 类，而不是 Object 类，因此枚举类不能显式继承其他父类。但可以实现一个或多个接口。 使用 enum 定义、非抽象的枚举类默认会使用 final 修饰，因此枚举类不能派生子类。 枚举类的构造器只能用 private 修饰。 枚举类的所有实例必须在枚举类的第一行显式列出，否则这个枚举类永远不能产生实例。并且这些实例都默认使用 public static final 修饰的类变量来保持。 123456public enum SeasonEnum&#123; //在第一行列出4个枚举 **实例**！！！ //每一个枚举值就是一个该枚举类的实例！！ SPRING,SUMMER,AUTUMN,WINTER;&#125; 当需要使用该枚举类的某个实例时，可使用 EnumClass.variable 的形式，例如 SeasonEnum.SPRING 。 枚举类默认有一个 values() 方法，可以返回该枚举类的所有实例：1234for(SeasonEnum s:SeasonEnum.values())&#123; System.out.println(s);&#125; 所有的枚举类都可以直接使用父类 java.lang.Enum 中提供的几个方法： int compareTo(E o)：该方法用于与指定枚举对象比较顺序，同一个枚举实例只能与相同类型的枚举实例进行比较。如果该枚举对象位于指定枚举对象之后，返回1；位于之前，返回-1；否则返回0。 String name()：返回此枚举实例的名称 int ordinal()：返回枚举值在枚举类中的索引值（即枚举值在枚举类声明中的位置，第一个枚举值的索引为 0）； String toString()：返回枚举常量的名称 public static&lt;T extends Enumn&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType，String name)：一个静态方法，用于返回指定枚举类中指定名称的枚举值。名称必须与在该枚举类中声明枚举值时所用的标识符完全匹配； 枚举类的成员变量、方法和构造器枚举类也是一个类，因此它一样可以定义成员变量、方法和构造器。 枚举类通常应该设计成不可变类，也就是说，它的成员变量不应该允许改变，这样会更安全，而且代码更简洁。因此建议将枚举类的成员变量都使用 private final 修饰。并且在构造器里为这些成员变量指定初始值。12345678910111213141516private enum Seanson &#123; SPRING("春"), SUMMER("夏"), FALL("秋"), WINTER("冬"); private final String name; private Seanson(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; &#125; 注意，枚举类在首次使用的时候就会通过构造器隐式全部构造出所有枚举实例！！！ 实现接口的枚举类枚举类也可以实现一个或多个接口，也需要实现该接口所包含的方法。如果需要每个枚举值在调用接口方法时呈现出不同的行为方式，则可以让每个枚举值分别去实现该接口方法，每个枚举值提供不同的实现方式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748interface SeasonDesc&#123; void info();&#125;enum Season implements SeasonDesc&#123; SPRING(&quot;春&quot;) &#123; @Override public void info() &#123; System.out.println(&quot;春天来了&quot;); &#125; &#125;, SUMMER(&quot;夏&quot;) &#123; @Override public void info() &#123; System.out.println(&quot;夏天来了&quot;); &#125; &#125;, FALL(&quot;秋&quot;) &#123; @Override public void info() &#123; System.out.println(&quot;秋天来了&quot;); &#125; &#125;, WINTER(&quot;冬&quot;) &#123; @Override public void info() &#123; System.out.println(&quot;冬天来了&quot;); &#125; &#125;; private String name; private Season(String name) &#123; this.name = name; System.out.println(this.name); &#125;&#125; 包含抽象方法的枚举类假设一个 Operation 枚举类，它的 4 个枚举值 PLUS、MINUS、TIMES、DIVIDE 分别代表 加、减、乘、除 4 种运算，该枚举类需要定义一个 eval() 方法来完成计算。 1234567891011121314151617181920212223242526272829303132333435363738private enum Operation&#123; //为该枚举类定义一个抽象方法 public abstract double eval(double x, double y); PLUS &#123; @Override public double eval(double x, double y) &#123; return x + y; &#125; &#125;, MINUS &#123; @Override public double eval(double x, double y) &#123; return x - y; &#125; &#125;, TIMES &#123; @Override public double eval(double x, double y) &#123; return x * y; &#125; &#125;, DIVIDE &#123; @Override public double eval(double x, double y) &#123; return x / y; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.8-Lambda表达式]]></title>
    <url>%2F2018%2F03%2F11%2FJava%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[当使用 Lambda 表达式代替匿名内部类创建对象时，Lambda 表达式的代码块将会代替实现抽象方法的方法体，Lambda 表达式就相当于一个匿名方法。 Lambda 表达式由三部分组成： 形参列表。形参列表允许省略形参类型，如果形参列表中只有一个参数，甚至连形参列表的圆括号都可以省略。 箭头-&gt; 代码块。如果代码块只有一条语句，Lambda 表达式允许省略代码块的花括号。如果代码块只有一条 return 语句，甚至可以省略 return 关键字。 函数式接口Lambda 表达式实际上将会被当成一个”任意类型”的对象，到底需要当成何种类型的对象，这取决于运行环境的需要。Lambda 表达式只能为函数式接口创建对象。 方法引用与构造器引用前面介绍过，如果 Lambda 表达式的代码块只有一条语句，程序就可以省略 Lambda 表达式中的代码块的花括号。不仅如此，如果 Lambda 表达的代码块只有一条语句，还可以在代码块中使用方法引用和构造器引用。1234567891011121314151617181920212223242526272829303132333435先定义一个接口类interface Converter&#123; Integer convert(String from);&#125;//方法引用代替 Lambda 表达式：引用类方法Converter converter= from -&gt; Integer.valueOf(from);//函数式接口中被实现方法的全部参数传给该类作为参数Converter converter= Integer::valueOf;//方法引用代替 Lambda 表达式：引用特定对象的实例方法Converter converter= from -&gt; &quot;fkit.org&quot;.indexOf(from);//函数式接口中被实现方法的全部参数传给该方法作为参数Converter converter= &quot;fkit.org&quot;::indexOf;//方法引用代替 Lambda 表达式：引用某类对象的实例方法interface MyTest&#123; String test(String a，int b，int c);&#125;MyTest mt= (a，b，c) -&gt; a.substring(b，c);//函数式接口中被实现方法的第一个参数作为调用者//后面的参数全部传给该方法作为参数MyTest mt= String::substring;//引用构造器代替 Lambda表达式interface YourTest&#123; JFrame win(String title);&#125;//使用 Lambda 表达式创建 YourTest 对象YourTest yt= (String a) -&gt; new JFrame(a);等同于YourTest yt=JFrame::new; Lambda 表达式于匿名内部类的联系和区别 Lambda表达式与匿名内部类一样，都可以直接访问局部变量，以及外部类的成员变量（包括成员变量和类变量）； Lambda表达式创建的对象与匿名内部类生产的对象一样，都可以直接调用从接口中继承的默认方法； 匿名内部类可以为任意接口创建实例-不管接口包含多少个抽象方法，只有匿名内部类实现所有的抽象方法即可；但Lambda表达式只能为函数式接口创建实例； 匿名内部类可以为抽象类甚至普通类创建实例，但Lambda表达式只能为函数式接口创建实例； 匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法；但Lambda表达式的代码块不允许调用接口中定义的默认方法；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CrazyJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate-悲观锁和乐观锁]]></title>
    <url>%2F2018%2F03%2F07%2FHibernate%2F%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[当多个事务同时访问数据库中的相同数据时，如果没有采取必要的隔离措施，将会导致各种并发问题，这时可以采用 悲观锁 或 乐观锁 对其进行控制。 悲观锁悲观锁 是指每次在操作数据时，总是悲观地认为会有其他事务也会来操作同一数据，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁由数据库来实现，在锁定的时间其他事务不能对数据进行存取，这样有可能造成长时间等待。在 Hibernate 中，用户可以显式地设定要锁定的表或字段及锁模式。 Hibernate 锁模式有如下几种： LockMode.NONE如果缓存中存在对象，直接返回该对象的引用，否则通过 SELECT 语句到数据库中加载该对象，这是锁模式的默认值。 LockMode.READ不管缓存中是否存在对象，总是通过 SELECT 语句到数据库中加载该对象，如果映射文件中设置了版本元素，就执行版本检查，比较缓存中的对象是否与数据库中的对象版本一致。 LockMode.UPGRADE不管缓存中是否存在对象，总是通过 SELECT 语句到数据库中加载该对象，如果映射文件中设置了版本元素，就执行版本检查，比较缓存中的对象是否与数据库中的对象版本一致，如果数据库系统支持悲观锁，就执行 SELECT … For UPDATE 语句，如果不支持，就执行普通 SELECT 语句。 LockMode.UPGRADE_NOWAIT与 LockMode.UPGRADE 具有同样功能，对于 Oracle 等支持 update nowait 的数据库，执行 select … for update nowait 语句，nowait 表明如果执行该 select 语句的事务不能立即获得悲观锁，那么不会等待其他事务来释放锁，而是立即抛出锁定异常。 LockMode.WRITE保存对象时会自动使用这种锁模式，仅供 Hibernate 内部使用，应用程序中不应该使用它。 LockMode.FORCE强制更新数据库中对象的版本属性，从而表明当前事务已经更新了这个对象。 设置锁模式的方法有： 调用 Session.load() 时指定锁模式。 调用 Session.lock()。 调用 Query.setLockMode()。 乐观锁乐观锁(Optimistic Locking) 通常认为多个事务同时操作同一个数据的情况很少发生，因此乐观锁不做数据库层次上的锁定，而是基于数据版本(Version)标识实现应用程序级别上的锁定机制，技能保证多个事务的并发操作，又能有效地防止第二类丢失更新的发生。 所谓的数据版本标识，就是通过为数据表增加一个 “version” 字段实现。读取数据时，将版本号一同读出，之后更新此数据时，将此版本号加一。在提交数据时，将现有的版本号与数据表对应记录的版本号进行对比，如果提交数据的版本号大于数据表中的版本号，则允许更新数据，否则禁止更新数据。 在 Hibernate 中，为乐观锁提供了两种基于版本控制的实现，分别是基于 version 的实现和基于 timestamp 的实现。 基于 version 的乐观锁创建数据表的时候在表最后增加一个 Version 字段： 字段名 数据类型 说明 id int(4) 编号，主键，非空，自增 AccountNo varchar(20) 账号，非空 Balance decimal(10,0) 余额，非空 Version int(4) 版本号 在实体类中给 version 实例变量添加 @Version 注解：123456@Version@Column(name = &quot;version&quot;)public Integer getVersion()&#123; return version;&#125; 基于 timestamp 的乐观锁为了使用基于 timestamp 的乐观锁，需要在数据表中添加一个表示版本信息的字段 LastUpdateTime，取代原先的 version 字段。 字段名 数据类型 说明 id int(4) 编号，主键，非空，自增 AccountNo varchar(20) 账号，非空 Balance decimal(10,0) 余额，非空 LastUpdateTime datetime 最后修改时间 在实体类中给 latestTimeStamp 实例变量添加 @UpdateTimestamp 注解：123456@UpdateTimestamp@Column(name = &quot;lastUpdateTime&quot;)public Timestamp getLastUpdateTime()&#123; return lastUpdateTime;&#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate-事务]]></title>
    <url>%2F2018%2F03%2F07%2FHibernate%2FHibernate-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务是数据库并发控制不可分割的基本逻辑单位，可以用于确保数据库能被正确修改，避免数据只修改了一部分而导致数据不完整，或者在修改时受到用户干扰。 事务的特性事务具有 原子性、一致性、隔离性 和 持久性，即 ACID 。原子性表示将事务中所做的操作捆绑成一个不可分割的单元，对于事务所进行的数据修改等操作，要么全部执行，要么全部都不执行。一致性表示事务在完成时,必须使所有的数据保持一致状态，而且在相关数据中，所有规则都必须应用于事务的修改，以保持所有数据的完整性，事务结束时，所有的内部数据结构都应该是正确的。隔离性表示由并发事务所做的修改必须与任何其他事务所做的修改相隔离，查看数据时，数据所处的状态要么是被另一个并发事务修改之前的状态，要么是被另一个并发事务修改之后的状态，即事务不会查看由另一个并发事务正在修改的数据；持久性 表示事务完成后，它对系统的影响是永久的，即使出现系统故障也可以由日志进行恢复。 并发控制在多个事务同时使用相同的数据时可能会发生问题，即并发问题。并发问题包括如下5种： 第一类丢失更新当多个事务同时操作同一个数据，撤消其中一个事务时，把其他事务已经提交的更新数据覆盖，对其他事务来说造成了数据丢失； 第二类丢失更新当多个事务同时操作同一个数据时，事务A将修改结果成功提交后，对事务B已经提交的修改结果进行了覆盖，对事务B来说造成了数据丢失； 脏读当多个事务同时操作同一个数据时，事务A读到事务B未提交的更新数据，且对数据进行操作，如果事务B撤销更新后，事务A所操作的数据便成了脏数据； 不可重复读当多个事务同时操作同一个数据时，事务A对同一行数据重复读取两次，每次读取的结果不同。有可能第二次读取数据的时候原始数据被事务B更改，并成功提交； 幻象读当多个事务同时操作同一个数据时，事务A执行两次查询，第二次查询结果比第一次查询多出一行，这是因为在两次查询之间事务B插入了新数据造成的； 隔离级别为了避免并发问题的发生，在标准SQL规范中，提出了 4 个事务隔离级别，在 Hibernate 配置文件中通过 hibernate.connection.isolation 属性来设置数据库的隔离级别&lt;property name=&quot;hibernate.connection.isolation&quot;&gt;2&lt;/property&gt; 序列号（8级）提供最严格的事务隔离，该隔离级别不允许事务并行执行，只允许一个接着一个执行，不能并发执行。此隔离级别可以有效防止 脏读、不可重复读 和 幻象读。 可重复读（4级）一个事务在执行过程中可以访问其他事务成功提交的新插入数据，但不能访问成功修改的数据。读取数据的事务将会禁止写事务，但允许读事务；写事务则禁止其他事务。此隔离级别可以有效防止不可重复读和脏读。 读已提交数据（2级）一个事务在执行过程中既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该数据。此隔离级别可以有效防止脏读。 读未提交数据（1级）一个事务在执行过程中既可以访问其他事务未提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则不允许另外一个事务同时进行写操作，但允许其他事务进行读操作。此隔离级别仅仅可以防止第一类丢失更新。 隔离级别越高，越能保证数据库的完整性和一致性，但对并发性能影响越大。通常设置为 2 级，即读已提交数据，它既能防止脏读，而且又有较好的并发性能。虽然 2 级会导致不可重复读、幻象读和第二类丢失更新这些并发问题，但可以通过在应用程序中采用悲观锁和乐观锁来加以控制。1&lt;property name=&quot;hibernate.connection.isolation&quot;&gt;2&lt;/property&gt;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate-批量处理]]></title>
    <url>%2F2018%2F03%2F06%2FHibernate%2FHibernate-%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[通过 Hibernate 缓存进行批量插入123456789101112131415161718192021222324public static void batchAddByCache() &#123; Session session = HibernateSessionFactory.getSession(); Transaction transaction = null; try &#123; transaction = session.beginTransaction(); for (int i = 1; i &lt; 1000000; i++) &#123; TbTest tbTest = new TbTest(&quot;测试&quot; + i, &quot;INFO&quot; + i); session.save(tbTest); &#125; transaction.commit(); &#125; catch (Exception e) &#123; if (transaction != null) &#123; transaction.rollback(); &#125; &#125; finally &#123; session.close(); &#125; &#125; 对于大批量的数据用 Hibernate 插入到数据库时容易发生 OutOfMemoryError(内存溢出异常)。 Hibernate 缓存分为一级缓存和二级缓存，对于二级缓存，Hibernate 可以对它的大小进行相关配置，而对于一级缓存，Hibernate 对它的容量没有限制。Hibernate 的 Session 持有一个必选的一级缓存，执行海量数据插入操作时，所有的实体类对象都会被纳入一级缓存(一级缓存是在内存中做缓存的)，这样内存就会被一点一点占用，直到内存溢出。 要解决内存溢出的问题，需要定时将 Session 缓存的数据刷入数据库，而不是一直在 Session 级别缓存，具体步骤如下： 设置批量尺寸。在 Hibernate 配置文件 hibernate.cfg.xml 中设置 hibernate.jdbc.batch_size 属性：1&lt;property name=&quot;hibernate.jdbc.batch_size&quot;&gt;100&lt;/property&gt; 以上的配置是等到程序积累到了 100 个SQL之后再批量提交。 关闭二级缓存。除了 Session 级别的一级缓存，Hibernate 还有一个 SessionFactory 级别的二级缓存。如果启用了二级缓存，从机制上来说，Hibernate 为了维护二级缓存，在批量插入时，Hibernate 会将实体类对象纳入二级缓存，容易损失性能，引发异常。因此最好关闭二级缓存。 1&lt;property name=&quot;hibernate.cache.user_second_level_cache&quot;&gt;false&lt;/property&gt; 清空 Session 级别的一级缓存。在进行批量操作的方法中，定时将 Session 级别的一级缓存中的数据刷入数据库，并清空 Session 缓存： 12345678910111213Session session=HibernateSessionFactory.getSession();Tranaction transaction=session.beginTransaction();for(int i=1;i&lt;1000000;i++)&#123; User user=new User(&quot;u&quot;+i); session.save(user); if(i%100 == 0) &#123; session.flush(); session.clear(); &#125;&#125;transaction.commit(); 绕过 Hibernate 直接使用 JDBC API 进行批量操作通过 JDBC API 中的 PreparedStatement 接口来执行 SQL 语句，SQL 语句中涉及到的数据不会被加载到 Session 的缓存中，因此不会占用内存空间。另外，直接调用 JDBC API 批量插入的效率要高于 Hibernate 缓存的批量插入。12345678910111213141516171819202122232425262728293031public static void batchAddByJDBC() &#123; Session session = HibernateSessionFactory.getSession(); Transaction transaction = null; try &#123; transaction = session.beginTransaction(); //执行 Work 对象指定的操作,即调用 Work 对象的 execute() 方法 //session 会把所有的数据库连接传给 execute() 方法 //这里使用了 Lambda表达式 session.doWork((connection) -&gt; &#123; String hql = &quot;insert into tb_test(name,info) values(?,?)&quot;; PreparedStatement preparedStatement = connection.prepareStatement(hql); for (int i = 1; i &lt; 1000000; i++) &#123; preparedStatement.setString(1, &quot;测试&quot; + i); preparedStatement.setString(2, &quot;INFO&quot; + i); preparedStatement.addBatch(); &#125; preparedStatement.executeBatch(); &#125;); transaction.commit(); &#125; catch (Exception e) &#123; if (transaction != null) &#123; transaction.rollback(); &#125; &#125;//注意不要关闭连接 &#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-事务管理]]></title>
    <url>%2F2018%2F03%2F05%2FSpring%2FSpring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring 事务管理由两种方式： 一种是传统的编程式事务管理，通过编写代码实现事务管理，包括定义事务的开始、程序正常执行后的事务提交、异常时进行的事务回滚。 另一种是基于 AOP 技术实现的声明式事务，其主要思想是将事务管理作为一个 “方面” 代码单独编写，程序员只关心核心业务逻辑代码，然后通过 AOP 技术将事务管理的 “方面” 代码织入到业务类中。声明式事务的缺点在于，只能作用于方法级别，无法做到像编程式事务那样能控制到代码块级别。 Spring 声明式事务管理既可以通过 AOP 配置方式实现，也可以通过 @Transactional 注解的方式来实现。Spring3 的事务规则也就是事务传播行为，常见的事务传播行为如下： 名称 说明 REQUIRED 表示当前方法必须运行在一个事务环境中，如果有一个现有事务正在运行中，该方法将运行在这个事务中，否则，就要开始一个新的事务 REQURIESNEW 表示当前方法必须运行在自己的事务里 SUPPORTS 表示当前方法不需要事务处理环境，但如果有一个事务正在运行的话，则这个方法也可以运行在这个事务中 MANDATORY 表示当前方法必须运行在一个事务上下文中，否则就抛出异常 NEVER 表示当前方法不应该运行在一个事务上下文中，否则就抛出异常 事务管理的主要任务是事务的创建、事务的回滚和事务的提交，是否需要创建事务以及如何创建事务，是由事务传播行为控制的，通常数据的读取可以不需要事务管理，或者可以指定为只读事务，而对于数据的增加、删除和修改操作，则有必要进行事务管理。如果没有指定事务的传播型行为，Spring3 默认将采用 REQUIRED。 基于 AOP 的事务管理下面开始配置基于 AOP 的事务管理。 所有的配置都是在 Spring 配置文件 applicationContext.xml 中完成： 在 &lt;beans&gt; 标记中添加 AOP 所需的常用命名空间声明： 123456&lt;beans xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; ... xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd ...&quot;&gt; 声明事务管理器。使用声明式事务，需要提供声明事务管理器。在 Spring 和 Hibernate 的整合中，在 Spring 配置文件中声明一个 Hibernate 事务管理器： 1234&lt;!-- 声明 Hibernate 事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;&lt;/bean&gt; 定义事务通知，首先指定一个事务管理器，然后在其属性中声明事务规则： 12345678&lt;!-- 定义事务通知 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 指定事务传播规则 --&gt; &lt;tx:attributes&gt; &lt;!-- 对所有方法应用 REQUIRED 事务规则 --&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 在定义事务传播规则时，对所有方法应用 REQUIRED 事务规则，表示当前方法必须运行在一个事务环境中，如果一个现有事务正在运行中，该方法将运行在这个事务中，否则，就开始一个新的事务。 定义一个切面，并将事务通知与切面组合，即定义哪些方法应用这些规则：123456&lt;aop:config&gt; &lt;!-- 对 com.ssh2.biz 包下的所有类的所有方法都应用事务规则 --&gt; &lt;aop:pointcut id=&quot;bizMethods&quot; expression=&quot;execution(* com.ssh2.biz.*.*(..))&quot; /&gt; &lt;!-- 将事务通知与切面组合 --&gt; &lt;aop:advice advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;bizMethods&quot; /&gt;&lt;/aop:config&gt; 到此，基于 AOP 的声明式事务配置完成了。 基于 @Transactional 注解的事务管理 参数名 说明 propagation 设置事务的传播规则，格式如：@Transactional(propagation=Propagation.REQUIRED) rollbackFor 需要回滚的异常类，当方法中抛出异常时，则进行事务回滚。单一异常类格式：@Transactional(rollbackFor=RuntimeException.class) 多个异常类格式：@Transactional(rollbackFor={RuntimeException.class,Exception.class}) rollbackForClassName 需要回滚的异常类名，当方法抛出指定异常类名称时，则进行回滚。单一异常类名称格式：@Transactional(rollbackForClassName=”RuntimeException”) 多个异常类名称格式：@Transactional(rollbackForClassName={“RuntimeException”,”Exception”}) isolation 事务隔离级别，用于处理多个事务并发，基本不需要设置 timeout 设置事务的超时秒数 readOnly 事务是否只读，设置为 true 表示只读]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实现SpringAOP--基于 @AspectJ 注解]]></title>
    <url>%2F2018%2F03%2F05%2FSpring%2FAOP-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring3 为 AOP 的实现提供了一套 Annotation 注解，如下： @AspectJ：用于定义一个切面。 @Pointcut：用于定义一个切入点，切入点的名称由一个方面名称定义。 @Before：用于定义一个前置通知。 @AfterReturning：用于定义一个后置通知。 @AfterThrowing：用于定义一个异常通知。 @Around：用于定义一个环绕通知。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//日志切面@Aspectpublic class AllLogAdviceByAnnotation&#123; private Logger logger=Logger.getLogger(AllLogAdviceByAnnotation.class); /** *使用 @Pointcut 注解定义一个切入点，切入点的名字为 allMethod()， *切入点的正则表达式 execution(* com.shw.biz.UserBiz.*(..)) *含义是对 com.shw.biz.UserBiz 中的所有方法进行拦截 **/ @Pointcut(&quot;execution(* com.shw.biz.UserBiz.*(..))&quot;) //定义切入点名字，切入点是一个方法 private void allMethod()&#123;&#125; //定义前置通知 @Before(&quot;allMethod()&quot;) public void myBeforeAdvice(JoinPoint joinpoint) &#123; //获取被调用的类名 String targetClassName=joinpoint.getTarget().getClass().getName(); //获取被调用的方法名 String targetMethodName=joinpoint.getSignature().getName(); //日志格式字符串 String logInfoText=&quot;前置通知：&quot;+ targetClassName + &quot;类的&quot; + targetMethodName + &quot; 方法开始执行 &quot;; //将日志信息写入配置文件中 logger.info(logInfoText); &#125; //定义后置通知 @AfterReturning(&quot;allMethod()&quot;) public void myAfterReturnAdvice(JoinPoint joinpoint) &#123; //获取被调用的类名 String targetClassName=joinpoint.getTarget().getClass().getName(); //获取被调用的方法名 String targetMethodName=joinpoint.getSignature().getName(); //日志格式字符串 String logInfoText=&quot;后置通知：&quot;+ targetClassName + &quot;类的&quot; + targetMethodName + &quot; 方法开始执行 &quot;; //将日志信息写入配置文件中 logger.info(logInfoText); &#125; //定义异常通知 @AfterThrowing(pointcut=&quot;allMethod()&quot;,throwing=&quot;e&quot;) public void myThrowingAdvice(JoinPoint joinpoint,Exception e) &#123; //获取被调用的类名 String targetClassName=joinpoint.getTarget().getClass().getName(); //获取被调用的方法名 String targetMethodName=joinpoint.getSignature().getName(); //日志格式字符串 String logInfoText=&quot;异常通知：执行&quot;+ targetClassName + &quot;类的&quot; + targetMethodName + &quot; 方法时发生异常 &quot;; //将日志信息写入配置文件中 logger.info(logInfoText); &#125; //定义环绕通知 @Around(&quot;allMethod()&quot;) public void myAroundAdvice(ProceedingJoinPoint joinpoint) throws Throwable &#123; long beginTime=System.currentTimeMillis(); joinpoint.proceed(); long endTime=System.currentTimeMillis(); //获取被调用的方法名 String targetMethodName=joinpoint.getSignature().getName(); //日志格式字符串 String logInfoText=&quot;环绕通知：&quot;+ targetMethodName + &quot; 方法调用前时间&quot; + beginTime + &quot;毫秒,&quot; + &quot;调用后时间&quot; + endTime + &quot;毫秒&quot;; //将日志信息写入配置文件中 logger.info(logInfoText); &#125; 为了让 @AspectJ 的注解能正常工作，需要在配置文件的 &lt;beans&gt; 标记中导入 AOP 命名空间及其配套的 schemaLocation 。还需要开启基于 @AspectJ 切面的注解处理器，并将日志通知 AllLogAdviceByAnnotation 交给 Spring 容器管理。1234&lt;!-- 开启基于 @AspectJ 切面的注解处理器 --&gt;&lt;aop:aspectj-autoproxy /&gt;&lt;!-- 将日志通知 AllLogAdviceByAnnotation 交给 Spring 容器管理 --&gt;&lt;bean class=&quot;com.shw.aop.AllLogAdviceByAnnotation&quot; /&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现SpringAOP--基于 Schema]]></title>
    <url>%2F2018%2F03%2F05%2FSpring%2FAOP-%E5%9F%BA%E4%BA%8EShema%2F</url>
    <content type="text"><![CDATA[基于 Schema 的AOP实现基于 Schema 的 AOP 通过 aop 命名空间来定义切面、切入点以及声明通知。在 Spring 配置文件中，所有的切面和通知都必须定义在&lt;aop:config&gt;元素内部。首先新建类 AllLogAdvice，并在类中编写用于演示的各种类型通知，在定义通知方法时传入一个连接点 JoinPoint 参数，通过该参数可以获取目标对象的类名、目标方法名和目标方法参数等信息：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class AllLogAdvice&#123; private Logger logger=Logger.getLogger(AllLogAdvice.class); //此方法将作为前置通知 public void myBeforeAdvice(JoinPoint joinpoint) &#123; //获取被调用的类名 String targetClassName=joinpoint.getTarget().getClass().getName(); //获取被调用的方法名 String targetMethodName=jointpoint.getSignature().getName(); //日志格式字符串 String logInfoText=&quot;前置通知：&quot;+ targetClassName + &quot;类的&quot; + targetMethodName + &quot;方法开始执行&quot;; //将日志信息写入配置的文件中 logger.info(logInfoText); &#125; //此方法将作为后置通知 public void myAfterReturnAdvice(JoinPoint joinpoint) &#123; //获取被调用的类名 String targetClassName=joinpoint.getTarget().getClass().getName(); //获取被调用的方法名 String targetMethodName=jointpoint.getSignature().getName(); //日志格式字符串 String logInfoText=&quot;后置通知：&quot;+ targetClassName + &quot;类的&quot; + targetMethodName + &quot;方法开始执行&quot;; //将日志信息写入配置的文件中 logger.info(logInfoText); &#125; //此方法将作为异常通知 public void myThrowingAdvice(JoinPoint joinpoint,Exception e) &#123; //获取被调用的类名 String targetClassName=joinpoint.getTarget().getClass().getName(); //获取被调用的方法名 String targetMethodName=jointpoint.getSignature().getName(); //日志格式字符串 String logInfoText=&quot;异常通知：执行&quot;+ targetClassName + &quot;类的&quot; + targetMethodName + &quot;方法时发生异常&quot;; //将日志信息写入配置的文件中 logger.info(logInfoText); &#125; //此方法将作为环绕通知 public void myAroundAdvice(ProceedingJoinPoint joinpoint) throws Throwable &#123; long beginTime=System.currentTimeMillis(); joinpoint.proceed(); long endTime=System.currentTimeMillis(); //获取被调用的方法名 String targetMethodName=jointpoint.getSignature().getName(); //日志格式字符串 String logInfoText=&quot;环绕通知：&quot;+ targetMethodName + &quot;方法调用前时间&quot; + beginTime + &quot;毫秒，&quot; + 调用后时间 + endTime + &quot;毫秒&quot;; //将日志信息写入配置的文件中 logger.info(logInfoText); &#125;&#125; 然后在 src 目录下新建一个配置文件 aop.xml，在配置文件中采用 AOP 配置方式实现 AOP 功能。从而将日志通知 AllLogAdvice 与业务组件 UserBiz 这两个原本互不相关的类和接口，通过在配置文件 aop.xml 中进行 AOP 装配后，实现了将 AllLogAdvice 类中的各种通知切入到 UserBiz 中，以实现预期的日志记录。aop.xml 配置文件的内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;&lt;beans xmlns=&quot;http://www.springframework.org/shcema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd&quot;&gt;&lt;!-- 配置创建 UserDAOImpl 的实例 --&gt;&lt;bean id=&quot;userDAO&quot; class=&quot;com.shw.dao.UserBizImpl&quot;/&gt;&lt;!-- 配置创建 UserBizImpl 的实例 --&gt;&lt;bean id=&quot;userBiz&quot; class=&quot;com.shw.biz.UserBizImpl&quot;&gt; &lt;!-- 依赖注入数据访问层组件 --&gt; &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt;&lt;/bean&gt;&lt;!-- 定义日志通知、将日志切面交给 Spring 容器管理 --&gt;&lt;bean id=&quot;allLogAdvcie&quot; class=&quot;com.shw.aop.AllLogAdvice&quot;/&gt;&lt;!-- 进行 aop 配置 --&gt;&lt;aop:config&gt; &lt;!-- 配置日志切面 --&gt; &lt;aop:aspect id=&quot;logaop&quot; ref=&quot;allLogAdvcie&quot;&gt; &lt;!-- 定义切入点，切入点采用正则表达式 execution(* com.shw.biz.UserBiz.*.(..))，含义是对 com.shw.biz.UserBiz 中的所有方法都尽心拦截 --&gt; &lt;aop:pointcut id=&quot;logpointcut&quot; expression=&quot;execution(* com.shw.biz.UserBiz.*(..))&quot;/&gt; &lt;!-- 将 LogAdvice 日志通知中的 myBeforeAdvice 方法指定为前置通知 --&gt; &lt;aop:before method=&quot;myBeforeAdvice&quot; pointcut-ref=&quot;logpointcut&quot;/&gt; &lt;!-- 将 LogAdvice 日志通知中的 myAfterReturnAdvice 方法指定为后置通知 --&gt; &lt;aop:after-returning method=&quot;myAfterReturnAdvice&quot; pointcut-ref=&quot;logpointcut&quot;/&gt; &lt;!-- 将 LogAdvice 日志通知中的方法指定为异常通知 --&gt; &lt;aop:after-throwing method=&quot;myThrowingAdvice&quot; pointcut-ref=&quot;logpointcut&quot; throwint=&quot;e&quot;/&gt; &lt;!-- 将 LogAdvice 日志通知中的方法指定为环绕通知 --&gt; &lt;aop:around method=&quot;myAroundAdvice&quot; pointcut-ref=&quot;logpointcut&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现SpringAOP--基于代理类]]></title>
    <url>%2F2018%2F03%2F05%2FSpring%2FAOP--%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基于代理类 ProxyFactoryBean 的AOP实现ProxyFactoryBean 是 FactoryBean 接口的实现类，FactoryBean 负责实例化一个 Bean，ProxyFactoryBean 则负责为其他 Bean 创建代理实例。使用 Spring 提供的 org.springframework.aop.framework.ProxyFactoryBean 是创建 AOP 的最基本方式，ProxyFactoryBean 的常用属性如下： target: 代理的目标对象 proxyInterfaces: 代理所要实现的接口，可以是多个接口 interceptorNames: 需要织入目标对象的 Bean 的列表 singleton: 返回的代理是否是单实例，默认为单实例 如果需要给添加用户和删除用户等业务逻辑方法添加业务日志功能，要求在业务方法调用时进行日志记录，日志内容包括被调用的类名、方法名等，并在控制台输出。以此为例，下面是基于代理类 ProxyFactoryBean 的AOP实现流程。 编写DAO层在数据访问层的 UserDAO 接口中声明用于添加和删除用户的两个方法并实现：12345public interface UserDAO&#123; void addUser(User user); void deleteUser(Integer id);&#125; 1234567891011public class UserDAOImpl implements UserDAO&#123; public void addUser(User user) &#123; System.out.print(userName+&quot;用户添加成功&quot;); &#125; public void deleteUser(Integer id) &#123; System.out.print(&quot;编号为：&quot;+id+&quot;的用户被删除&quot;); &#125; 编写业务逻辑层12345public interface UserBiz&#123; void addUser(User user); void deleteUser(Integer id);&#125; 1234567891011121314151617public class UserBizImpl implements UserBiz&#123; UserDAO userDAO; public void setUserDAO(UseDAO userDAO) &#123; this.userDAO=userDAO: &#125; public void addUser(User user) &#123; userDAO.addUser(user); &#125; public void deleteUser(Integer id) &#123; userDAO.deleteUser(id); &#125; 编写方面代码实现特定功能的方面代码在 AOP 概念中称为 “通知(advice)”。通知根据其织入到业务代码时执行的时间进行划分，分为前置通知、后置通知、环绕通知和异常通知。首先编写实现前置通知的 LogAdvice 类：12345678910111213141516public class LogAdvice implements MethodBeforeAdvice&#123; //获取日志记录器Logger private Logger logger=Logger.getLogger(LogAdvice.class); @Override public void before(Method method,Object[] args,Object target) throws Throwable &#123; //获取被调用的类名 String targetClassName=target.getClass().getName(); //获取被调用的方法名 String targetMethodName=method.getName(); //日志格式字符串 String logInfoText=&quot;前置通知：&quot;+ targetClassName + &quot;类的&quot; + targetMethodName + &quot;方法开始执行&quot;； //将日志信息写入配置的文件中 logger.info(logInfoText); 前置通知类要实现 MethodBeforeAdvice 接口，实现 before 方法；后置通知类要实现 AfterReturningAdvice 接口，实现 afterReturning 方法；异常通知类要实现 ThrowsAdvice 接口，实现 afterThrowing 方法；环绕通知类要实现 MethodInterceptor 接口，实现 invoke 方法； 将”业务逻辑代码”和”方面代码”组装进代理类Spring 采用代理的方式将通知织入到原先的 Bean 中。即 Spring 将原来的 Bean 和通知都封装到 org.springframework.aop.framework.ProxyFactoryBean 类中。该工作可在配置文件 applicationContext.xml 中完成。12345678910111213141516171819202122232425262728293031&lt;!-- 配置创建 UserBizImpl 的实例 --&gt;&lt;bean id=&quot;userBiz&quot; class=&quot;com.shw.biz.UserBizImpl&quot;&gt; &lt;!-- 依赖注入数据访问层组件 --&gt; &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt;&lt;/ben&gt;&lt;!-- 定义前置通知 --&gt;&lt;bean id=&quot;logAdvice&quot; class=&quot;com.shw.aop.LogAdvice&quot;/&gt;&lt;!-- 使用 Spring 代理工厂定义一个代理,名称为 ub,通过 ub 访问业务类中的方法 --&gt;&lt;bean id=&quot;ub&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;!-- 指定代理接口 --&gt; &lt;property name=&quot;proxyInterfaces&quot;&gt; &lt;value&gt;com.shw.biz.UserBiz&lt;/value&gt; &lt;/proerty&gt; &lt;!-- 指定通知 --&gt; &lt;property name=&quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;!-- 织入前置通知 --&gt; &lt;value&gt;logAdvice&lt;/value&gt; &lt;!-- 织入后置通知 --&gt; &lt;value&gt;afterAdvice&lt;/value&gt; &lt;!-- 织入环绕通知 --&gt; &lt;value&gt;logAroundAdvice&lt;/value&gt; &lt;!-- 织入异常通知 --&gt; &lt;value&gt;throwsLogAdvice&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 指定目标对象 --&gt; &lt;property name=&quot;target&quot; ref=&quot;userBiz&quot;/&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCPIP基础知识]]></title>
    <url>%2F2018%2F02%2F16%2FTCPIP%2FTCPIP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[IP地址的定义IP地址（IPV4）由32位二进制数来表示。为了便于理解，将32位的IP地址以每８位为一组，分成４组，一个字节为一组，再将每组数转换为十进制数。因此，IPV４一共可以最多允许2的32次方台计算机连接到网络。实际上，IP地址并非是根据主机台数来配置的，而是每一台主机上的每一块网卡都得设置IP地址。通常一个网卡只设置一个IP地址，其实一块网卡也可以设置多个IP地址。此外，一台路由器通常都会设置两个以上的网卡，因此可以设置两个以上的IP地址。 IP地址由网络和主机两部分表示组成IP地址由 “网络标识” 和 “主机标识” 两部分组成。IP地址的主机标识IP地址的网络标识注意：”192.168.128.10/24”中的”/24”表示从二进制IP地址的第1位开始到多少位属于网络标识。在这个例子中，”192.168.128”之前的都是该IP的网络地址。 IP地址的分类IP地址分为四个级别，分别为A类、B类、C类、D类。它根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。A类地址A类IP地址是首位以”0”开头的地址。从第1位到第8位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0是A类的网络地址。A类地址的后24位相当于主机标识。B类地址B类IP地址是前两位为”10”的地址。从第1位到第16位是它的网络标识。用十进制表示的话，128.0.0.1~191.255.0.0是B类的网络地址。B类的后16位相当于主机号。C类地址C类IP地址是前三位为”110”的地址。从第1位到第24位是它的网络标识。用十进制表示的话，192.168.0.0~239.255.255.0是C类的网络地址。C类地址的后8位相当于主机标识。D类地址D类IP地址是前四位为”1110”的地址。从第1位到第32位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255是D类的网络地址。D类地址没有主机标识，常被用于多播。关于分配IP主机地址的注意要用比特位表示主机地址时，不可以全部为0或全部为1。因为只有0在表示对应的网络地址或IP地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。 广播地址广播地址用于在同一个链路中相互连接的主机之间发送数据，把IP地址中的主机地址部分全部设置为1，就成了广播地址。两种广播地址广播地址分为本地广播和直接广播。在本网络内的关播叫做本地广播。例如网络地址为192.168.0.0/24的情况下，广播地址是192.168.0.255。因为这个广播地址的IP包会被路由器屏蔽，所以不会到达192.168.0.0/24以外的其他链路上。在不同网络之间的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向192.168.1.255/24的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.0/24，从而使得所有192.168.1.1~192.168.1.254的主机都能收到这个包。 IP多播多播用于将包发送给特定组内的所有主机。由于其直接使用IP协议，所以也不存在可靠传输。在人们使用多播功能之前，一直采用广播的方式。那时广播将数据发送给所有终端主机，再由这些主机IP之上的一层去判断是否有必要接收数据，是则接收，否则丢弃。然而这种方式会给那些毫无关系的网络或主机带来影响，造成网络上很多不必要的流量。况且由于广播无法穿透路由，若想给其他网段发送同样的包，就不得不采取另一种机制。因此，多播这种既可以穿透路由器，又可以实现只给那些必要的组发送数据包的技术就称为必选。IP多播与地址多播使用D类地址。 子网掩码（重点）一个IP地址只要确定了其分类，也就确定了它的网络标识和主机标识。直接使用A类、B类、C类地址会非常浪费，因此，如今一个IP地址的网络标识和主机标识已经不再受限于该地址的类别，而是由一种叫做”子网掩码”的识别码通过子网网络地址细分出比A类、B类、C类更小粒度的网络。这种方式实际上就是将原来A类、B类、C类等分类中的主机地址部分用作于子网地址，可以将原网络分为多个物理网络的一种机制。自从引入了子网以后，一个IP地址就有了两种识别码。一个是IP地址本身，另一个是表示网络部的子网掩码。子网掩码用二进制表示的话，也是一个32位的数字。它对应IP地址网络标识部分的位全部为”1”，对应IP地址主机标识部分则全部为”0”。由此，一个IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由定位自己的网络标识长度。子网掩码有两种表示方式：分别用两行表示IP地址和子网掩码IP地址：172.20.100.52(前26位是网络地址)子网掩码：255.255.255.192=11111111.11111111.11111111.11000000网络地址：172.20.100.0子网掩码：255.255.255.192广播地址：172.20.100.63子网掩码：255.255.255.192在每个IP地址后面追加网络地址的位数，用”/“隔开IP地址：172.20.100.52 /26网络地址：172.20.100.0 /26广播地址：172.20.100.63 /26]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-面向方面编程]]></title>
    <url>%2F2018%2F02%2F14%2FSpring%2FSpring-%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[日志、事务、安全验证等这些 “通用的”、散布在系统各处的需要再实现业务逻辑时关注的事情称为 “方面”，也可称为 “关注点”。如果能将这些 “方面” 集中处理，然后在具体运行时，再由容器动态织入这些“方面”，至少有以下好处： 可减少 “方面” 代码里的错误，处理策略改变时还能做到统一修改。 在编写业务逻辑时可以专心于核心业务。 因此，AOP要做的事情就是从系统中分离出 “方面”，然后集中实现。从而可以独立地编写业务代码和方面代码，在系统运行时，再将方面 “织入” 到系统中。 AOP的几个重要概念切面方面的实现，如日志切面、事务切面、权限切面等。在实际应用中通常是存放方面实现的普通Java类，要被AOP容器识别为切面，需要在配置中通过&lt;bean&gt;标记指定。通知是切面的具体实现，能实现特定的功能。以目标方法为参照点。根据放置的位置不同，可以分为前置通知、后置通知、异常通知、环绕通知和最终通知5种。切面类中的某个方法属于哪类通知，需要在配置中指定。切入点用于定义通知应该织入到哪些连接点上。目标对象指将要织入切面的对象。这些对象中只包含核心业务逻辑代码，所有日志、事务、安全验证等方面的功能等待AOP容器的织入。代理对象将通知应用到目标对象之后，被动态创建的对象。代理对象的功能相当于目标对象中实现的核心业务逻辑功能加上方面代码实现的功能。织入将切面应用到目标对象，从而创建一个新的代理对象的过程。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F02%2F14%2FTCPIP%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP/IPTCP/IP协议族按层次分别分为以下4层： 应用层应用层决定了向用户提供应用服务时通信的活动。FTP、DNS、HTTP 传输层传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。传输层有两个性质不同的协议：TCP和UDP 网络层网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。 链路层硬件上的范畴均在链路层的作用范围之内。 简单的HTTP协议HTTP请求报文 由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体。 HTTP响应报文 由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 HTTP中可使用的方法GET：获取资源POST：传输实体主体PUT：传输文件在请求报文的主题中包含文件内容，然后保存到请求URI指定的位置。响应的意思是请求执行成功了，但无数据返回。HEAD：获得报文首部HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。DELETE：删除文件DELETE方法按请求URI删除指定资源。OPTIONS：询问支持的方法OPTIONS方法用来查询针对请求URI指定的资源支持的方法。TRACE：追踪路径TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。CONNECT：要求用隧道协议连接代理 Cookie 返回结果的HTTP状态码 与HTTP协作的Web服务器通信数据转发程序：代理、网关、隧道以上的应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。 代理扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。使用代理可以利用缓存技术减少网络带宽的流量。代理按两种基准分类，一种是是否使用缓存，另一种是是否会修改报文。缓存代理代理转发响应时，缓存代理会预先将资源的副本保存再代理服务器上，当代理再次接收到对相同资源的请求时，可以将之前缓存的资源作为响应返回。透明代理转发请求或响应时，不对报文做任何加工的代理类型称为透明代理。 网关网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。利用网关可以由HTTP请求转化为其他协议通信。 隧道隧道是再相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。使用SSL等加密手段进行通信。 HTTP首部使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。首部字段结构首部字段名：字段值例如，Content-Type这个字段表示报文主体的对象类型Content-Type：text/html 4种首部字段类型通用首部字段请求报文和响应报文都会使用的首部。 请求首部字段从客户端向服务器发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段从服务器向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的信息。 实体首部字段针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等于实体内容有关的信息。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hinbernate-基于注解的关联映射]]></title>
    <url>%2F2018%2F02%2F14%2FHibernate%2FHinbernate-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Hibernate 的关联映射，包括单向多对一关联、单向一对多关联、双向多对一关联、双向一对一关联、多对多关联。 双向多对一单向多对一映射：由 “多(作为从表，建立外键)” 的一方指向 “一(作为主表)” 的一方。例如，图书信息表 books 和出版社信息表 publishers 的对应关系就是一种多对一关系。 单向一对多映射：Books 对 Publishers 是单向多对一关联，反过来看，Publishers 对 Books 就是单向一对多关联，即一个出版社可以出版多本图书。意味着每个 Publishers 对象会引用一组 Books 对象，因此在 Publishers 类中定义一个集合类型的属性，在访问 “一” 的一方 Publishers 对象时，关联的 “多” 的一方 Books 的多个对象将保存到该集合类型的属性中。 把单向多对一和单向一对多两者集合起来，就形成了双向关联。在实体类中，把类 Books 的 PublisherId 单独作为一个类变量，使用 @ManyToOne 和 @JoinColumn 注解实现 Books 到 Publishers 的多对一关系。 基于 Annotation 注解实现的实体类 Books：1234567891011//定义 Publishers 类型的关联属性private Publishers publishers；//使用 @ManyToOne 和 @JoinColumn 注解实现 Books 到 Publishers 的多对一关联@ManyToOne(fethch=FetchType.EAGER)@Cascade(value=&#123; CascadeType.SAVE_UPDATE &#125;)@JoinColumn(name=&quot;PublisherId&quot;)public Publishers getPublishers()&#123; return publishers;&#125; 注：@ManyToOne 注解的属性 fetch 属性的可选择项包括 FetchType.EAGER 和 FetchType.LAZY，前者表示加载 Books 对象时就会同时加载关联的 Publishers 对象，后者表示延迟加载，默认值是 FetchType.LAZY。@Cascade(value={CascadeType.SAVE_UPDATE}) 注解指定类与类之间的级联关系，主类执行保存或更新操作时，关联类执行同样的操作。@JoinColumn(name=&quot;PublicsherId&quot;) 指定数据表 books 的 PublisherId 字段作为外键与数据表 pubishers 的主键关联。 基于 Annotation 注解实现的实体类 Publishers：12345678910//定义元素类型为 Books 的关联集合属性 bksprivate Set&lt;Books&gt; bks=new HashSet&lt;&gt;();//使用 @OneToMany 注解实现 Publishers 到 Books 的一对多关联@OneToMany(mappedBy=&quot;publishers&quot;,fetch=FetchType.EAGER)@Cascade(value=&#123;CascadeType.DELETE&#125;)public Set&lt;Books&gt; getBks()&#123; return bks;&#125; 注:@OneToMany 注解的 mappedBy 属性的作用相当于设置 inverse=true，表示将关联关系的主管权反转，即由 Books 管理关联关系，mappedBy 的属性值为关联的多的一方(Books类)所定义的 Publicshers 类型的属性(publishers)。@Cascade(value={ CascadeType.DELETE } 注解指定级联删除。 双向一对一关联映射一对一关联 可以分为 基于外键的一对一关联 和 基于主键的一对一关联。 基于外键的一对一映射基于外键的一对一关联与多对一关联实质相同，是多对一关联的一个特例。特别之处在于在表示 “多” 的从表中外键必须是 unique。例如，公民表 people 和身份证表 identitycard 的关系属于一对一关联。公民表 people 的 CardId 字段作为外键，必须保证唯一。 基于主键的一对一映射基于主键的一对一关联就是限制两个数据表的主键使用相同的值，通过主键形成一对一映射关联，根据对方主键生成自己的主键。 基于 Annotation 注解实现的持久化类 PeopleZj 的代码：12345678910111213141516171819202122232425262728293031323334353637@Entity@Table(name=&quot;people_zj&quot;,catalog=&quot;bookshop&quot;)public class PeopleZj&#123; private Integer id; private String name; private String sex; //定义 IdentitycardZj 类型关联属性 private IdenttitycardZj identitycardZj; //定义默认构造器以及不含 identitycardZj 成员变量的构造器 public PeopleZj() &#123;&#125; public PeopleZj(String name,String sex,Integer age) &#123; this.name=name; this.sex=sex; this.age=age; &#125; //以下注解的功能是将当前对象中 identitycardZj 属性的主键来作为本对象的主键 @GenericGenerator(name=&quot;generator&quot;,strategy=&quot;foreign&quot;,parameter=@Parameter(name=&quot;property&quot;,value=&quot;identitycardZj&quot;)) @Id @GeneratedValue(generator=&quot;generator&quot;) @Column(name=&quot;Id&quot;,unique=true,nullable=false) public Integer getId() &#123; return this.id; &#125; //使用 @OneToMany 注解实现 PeopleZj 与 IdentitycardZj 的基于主键的一对一关联 @OneToMany(mappedBy=&quot;peopleZj&quot;,optional=false) public IdentitycardZj getIdentitycardZj() &#123; return identitycardZj; &#125; @GenericGenerator 注解声明了一个 Hibernate 的主键生成策略，该注解的 name 属性指定生成器名称，strategy 属性指定具体生成器的类名(即生成策略)，这里选择 foreign 策略，表示使用另一个关联对象的主键。parameter 属性得到 strategy 指定的具体生成器所用到的参数，设置 values=”identitycardZj”，表示将当前类 PeopleZj 中定义的 IdentitycardZj 类型的 identitycardZj 属性的主键作为 PeopeZj 类对象的主键。 基于 Annotation 注解实现的持久化类 IdentitycardZj 的代码：123456789101112131415161718@Entity@Table(name=&quot;identitycard_zj&quot;,catalog=&quot;bookshop&quot;)public class IdentitycardZj &#123; private Integer id; private String cardNo; //定义 PeopleZj 类型的关联属性 private PeopleZj peopleZj; //使用 @OneToOne 和 @PrimaryKeyJoinColumn 注解 //实现 IdentitycardZj 与 PeopleZj 的基于注解的一对一关联 @OntToOne(cascade=CascadeType.ALL) @PrimaryKeyJoinColumn public PeopleZj getPeopleZj() &#123; return peopleZj; &#125; 属性 cascade=CascadeType.ALL 表示 IdentitycardZj 类执行的所有操作 PeolpleZj 都会级联执行。@PrimaryKeyJoinColumn 表示两个实体类通过主键关联 多对多关联映射一个学生可以选择多个课程，而一门课程可以被多个学生选择，这样就形成了多对多关联。 可以通过一个中间表来维护两者之间的多对多关联。sc 表以 Sid 和 Cid 作为 联合主键，其中，Sid 字段作为外键指向 Student 表，Cid 字段作为外键指向 Course 表。1234alter table scadd constraint FK_Sid foreign key sc(Sid) references student(StudentId)alter table scadd constraint FK_Cid foreign key sc(Cid) references course(CourseId) 基于 Annotation 注解实现的持久化类 Course 的代码：12345678910111213141516@Entity@Table(name=&quot;course&quot;,catalog=&quot;bookshop&quot;)public class Course&#123; private Integer courseId; private String courseName; //定义元素类型为 Student 的选课学生集合 students private Set&lt;Student&gt; students = new HashSet&lt;&gt;(); //使用 @ManyToMany 注解实现 Course 到 Student 的多对多关联 @ManyToMany(mappedBy=&quot;course&quot;,fethch=FetchType.EAGER) public Set&lt;Student&gt; getStudent() &#123; return students; &#125; 基于 Annotation 注解实现的持久化类 Student 的代码：123456789101112131415161718@Entity@Table(name=&quot;student&quot;,catalog=&quot;bookshop&quot;)public class Student&#123; private Integer studentId; private String studentName; //定义元素类型为 Course 的选修课程集合 private Set&lt;Course&gt; courses = new HashSet&lt;&gt;(); //使用 @ManyToMany 注解实现 Student 到 Course 的多对多关联 @ManyToMany(fetch=FetchType.EAGER) @Cascade(value=&#123; CascadeType.SAVE_UPDATE &#125; @JoinTable(name=&quot;sc&quot;,joinColumns=&#123; @JoinColumn(name=&quot;Sid&quot;),inverseJoinColumn=&#123;@JoinColumn(name=&quot;Cid&quot;)&#125; &#125; public Set&lt;Course&gt; getCourse() &#123; return courses; &#125; @JoinTable 注解描述了多对多关系的数据表关系，name 属性指定中间表的名称，这里为 “sc”；joinColumns 属性定义了中间表 sc 与学生表 student 关联的外键列，这里为 “Sid”；inverseJoinColumns 属性定义中间表 sc 与另一端课程表 course 关联的外键列 ，这里为 “Cid”。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
</search>
